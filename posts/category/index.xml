<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Top Category on small land</title><link>https://uh-zz.github.io/posts/category/</link><description>Recent content in Top Category on small land</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 05 May 2022 18:52:33 +0900</lastBuildDate><atom:link href="https://uh-zz.github.io/posts/category/index.xml" rel="self" type="application/rss+xml"/><item><title>2024年の振り返り</title><link>https://uh-zz.github.io/posts/category/look-back-on/2024/12/31/</link><pubDate>Tue, 31 Dec 2024 00:00:00 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/look-back-on/2024/12/31/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>今年も気がつけばあっという間の一年でした。&lt;/p>
&lt;h2 id="バックナンバー">バックナンバー&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://uh-zz.github.io/posts/category/look-back-on/2021/" target="_blank" rel="noopener">2021 年の振り返り&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://uh-zz.github.io/posts/category/look-back-on/2022/12/31/" target="_blank" rel="noopener">2022 年の振り返り&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://uh-zz.github.io/posts/category/look-back-on/2023/12/24/" target="_blank" rel="noopener">2023 年の振り返り&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="202401">2024/01&lt;/h3>
&lt;h4 id="仕事">仕事&lt;/h4>
&lt;p>前職の同僚に誘ってもらい、新しい環境で副業を始めました。&lt;/p>
&lt;p>新規案件でかつ、バックエンドの技術選定から参画することになりました。&lt;/p>
&lt;p>なるべく少人数でかつ、言語経験者が少ない中でスピード感をもって開発できるようにしたいという要望を踏まえて、自分の中で最良のアーキテクチャを考えるのがすごく楽しかったのを覚えています。&lt;/p>
&lt;h4 id="プライベート">プライベート&lt;/h4>
&lt;p>Auth 屋さんの本を読みました。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">社のドキュメント読むために、Auth屋さんの本で改めて勉強してみて、雰囲気わかるからだいぶ整理できました&lt;a href="https://t.co/gyIbYnT4Gz">https://t.co/gyIbYnT4Gz&lt;/a>&lt;/p>&amp;mdash; reo (@_uhzz_) &lt;a href="https://twitter.com/_uhzz_/status/1745301805846937644?ref_src=twsrc%5Etfw">January 11, 2024&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h3 id="202402">2024/02&lt;/h3>
&lt;h4 id="仕事-1">仕事&lt;/h4>
&lt;p>たしかこの時期はスキーマ変更の多い機能を開発していました。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">いつか使うときが来ると確信した、令和はこれでいく&lt;a href="https://t.co/350E4A8El3">https://t.co/350E4A8El3&lt;/a>&lt;/p>&amp;mdash; reo (@_uhzz_) &lt;a href="https://twitter.com/_uhzz_/status/1757343230470115486?ref_src=twsrc%5Etfw">February 13, 2024&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h4 id="大学">大学&lt;/h4>
&lt;p>以下の科目習得試験を受験しました。&lt;/p>
&lt;ul>
&lt;li>論理回路&lt;/li>
&lt;li>微分積分 1&lt;/li>
&lt;/ul>
&lt;p>昨年の分をここで取り返しました。&lt;/p>
&lt;h4 id="プライベート-1">プライベート&lt;/h4>
&lt;p>初めて確定申告をしました。&lt;/p>
&lt;p>初回だいぶ苦戦を強いられたのですが、もう第二回が近づいてきてると思うと少し憂鬱です。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">月に一度は通うくらいお気に入りですが、しばらく投稿をサボっていました&lt;br>&lt;br>確定申告を完了させた開放感から、朝サウナをキメることにしました&lt;br>&lt;br>アロマロウリュのあるサウナと迷い... (＠ 多摩境天然温泉 森乃彩 in 東京都, 町田市) &lt;a href="https://t.co/PF36kygWA8">https://t.co/PF36kygWA8&lt;/a>&lt;/p>&amp;mdash; reo (@_uhzz_) &lt;a href="https://twitter.com/_uhzz_/status/1763046059776045121?ref_src=twsrc%5Etfw">February 29, 2024&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;p>また、この時期に初めて北海道に行きました。&lt;/p>
&lt;p>雪まつり直後だったのですが、自分の身長より高く積もった雪の中滑る道路を歩けたのは、南国生まれとして感慨深かったです。&lt;/p>
&lt;p>初めて見たこのオブジェに感動したので写真を撮っていました。(砂箱というらしいです)&lt;/p>
&lt;img src="https://uh-zz.github.io/posts/category/look-back-on/2024/12/31/trip_hokkaido.jpg"
alt="trip in hokkaido"
width="500"
>
&lt;h3 id="202403">2024/03&lt;/h3>
&lt;h4 id="仕事-2">仕事&lt;/h4>
&lt;p>転職しました。経緯については入社エントリに書きましたのでぜひ一読ください。&lt;/p>
&lt;p>&lt;a href="https://zenn.dev/finatext/articles/entry-finatext" target="_blank" rel="noopener">【入社エントリ】Finatext に入社して９ヶ月経ちました&lt;/a>&lt;/p>
&lt;h4 id="プライベート-2">プライベート&lt;/h4>
&lt;p>PostgreSQL で全文検索するための&lt;code>pg_bigm&lt;/code>について調べていました&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">調べるほど沼ってたけど、この資料で腹落ちできた(特にfastupdateがイメージ図が助かりました)&lt;a href="https://t.co/DS6GyUnrzv">https://t.co/DS6GyUnrzv&lt;/a>&lt;/p>&amp;mdash; reo (@_uhzz_) &lt;a href="https://twitter.com/_uhzz_/status/1768858737044082829?ref_src=twsrc%5Etfw">March 16, 2024&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h3 id="202404">2024/04&lt;/h3>
&lt;h4 id="仕事-3">仕事&lt;/h4>
&lt;p>Go Conference 2024 の LT が採択されて、2024 年上半期で一番アガりました。&lt;/p></description></item><item><title>Go Conference 2024参加レポ</title><link>https://uh-zz.github.io/posts/category/look-back-on/2024/06/08/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/look-back-on/2024/06/08/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>先日、オフラインで開催された Go Conference 2024 に参加してきました。&lt;/p>
&lt;p>&lt;a href="https://gocon.jp/2024/" target="_blank" rel="noopener">https://gocon.jp/2024/&lt;/a>&lt;/p>
&lt;p>Go Conference で登壇デビューできた感想と、リアタイできた発表のレポートをしていきます。&lt;/p>
&lt;p>発表レポ(というか感想)は、&lt;a href="#%e3%83%aa%e3%82%a2%e3%82%bf%e3%82%a4%e3%81%a7%e3%81%8d%e3%81%9f%e7%99%ba%e8%a1%a8">リアタイできた発表&lt;/a>をご参照ください。(しばらくポエムになります)&lt;/p>
&lt;h2 id="発表緊張した">発表緊張した…&lt;/h2>
&lt;p>当日の発表スライドはこちらです&lt;/p>
&lt;iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/3e521da6f3e84afab30dd21521cc361d" title="自動生成されたhttpエンドポイントごとにカスタムミドルウェアを挿入したい話" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 60%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777">&lt;/iframe>
&lt;p>&lt;a href="https://gocon.jp/2024/sessions/21/" target="_blank" rel="noopener">https://gocon.jp/2024/sessions/21/&lt;/a>&lt;/p>
&lt;p>まずは、発表のためにフィードバックをいただいた皆さんほんとにありがとうございました！！&lt;/p>
&lt;p>また、激励してくれた同僚＆元同僚にもほんとに感謝です &amp;#x1f64f;&lt;/p>
&lt;p>どうしても発表は緊張するものなのですが、スライドはみんなに見てもらって恥ずかしくないものを持ってきた、というのが心の支えになりました。&lt;/p>
&lt;p>おかげで、当日は気持ちよく発表することができました。&lt;/p>
&lt;p>会場からの反応もいただくことができて、発表後のエゴサが止まりませんでした笑&lt;/p>
&lt;p>こちらもありがとうございます&amp;#x1f44b;&lt;/p>
&lt;p>&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">足向けて寝られないぐらいお世話になってる oapi-codegen&lt;a href="https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw">#gocon&lt;/a>&lt;/p>&amp;mdash; RADISH (@ruby_engineer) &lt;a href="https://twitter.com/ruby_engineer/status/1799386755399033217?ref_src=twsrc%5Etfw">June 8, 2024&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">oapi-codegenの生成コードを使うと、endpointごとに個別のミドルウェアを差し込めない課題がある。&lt;br>わかる！そうだよそこだよ！&lt;br> &lt;a href="https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw">#gocon&lt;/a>&lt;/p>&amp;mdash; 鹿 (@mizushika1) &lt;a href="https://twitter.com/mizushika1/status/1799386957409403298?ref_src=twsrc%5Etfw">June 8, 2024&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">oapi-codegenメインで使ってるから助かる&lt;a href="https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw">#gocon&lt;/a>&lt;/p>&amp;mdash; パンダム/rymiyamoto (@rymiyamoto129) &lt;a href="https://twitter.com/rymiyamoto129/status/1799387433102172397?ref_src=twsrc%5Etfw">June 8, 2024&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">ちょうど oapi-codegen で chi のサーバーボイラープレートを試してたけど、パスごとのカスタムミドルウェア周り課題あるなあというのを思ってた &lt;a href="https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw">#gocon&lt;/a>&lt;/p></description></item><item><title>2023年の振り返り</title><link>https://uh-zz.github.io/posts/category/look-back-on/2023/12/24/</link><pubDate>Sun, 24 Dec 2023 03:56:24 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/look-back-on/2023/12/24/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>今年はここ数年でも特に怒涛の 1 年でした。&lt;/p>
&lt;p>公私共に変化が激しくて、心が折れそうになりながらもなんとか乗り切った感があります。&lt;/p>
&lt;p>いつも通り(?)需要の有無に関わらず振り返っていきたいと思います。&lt;/p>
&lt;h2 id="バックナンバー">バックナンバー&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://uh-zz.github.io/posts/category/look-back-on/2021/" target="_blank" rel="noopener">2021 年の振り返り&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://uh-zz.github.io/posts/category/look-back-on/2022/12/31/" target="_blank" rel="noopener">2022 年の振り返り&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="202301">2023/01&lt;/h3>
&lt;h4 id="仕事">仕事&lt;/h4>
&lt;p>新年明けてすぐ、所属チームを異動することになりました。&lt;/p>
&lt;p>入社してから n 年後には、そのチームでチャレンジしたいと思っていたのですごくワクワクしました。&lt;/p>
&lt;h4 id="プライベート">プライベート&lt;/h4>
&lt;p>週 1 で ROOFTOP サウナに行ってました。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">&lt;a href="https://twitter.com/hashtag/%E3%82%B5%E3%82%A6%E3%83%8A?src=hash&amp;amp;ref_src=twsrc%5Etfw">#サウナ&lt;/a>&lt;br>今年のサウナ初めでした。&lt;br>こちらに来るのは４，５回目です。&lt;br>&lt;br>２時間で4セット回しましたがあっという間でした。&lt;br>&lt;br>今日のアロマは木？の香りで、ロウリュ直後... (＠ ROOFTOP in 東京都, 杉並区) &lt;a href="https://t.co/pavDmbYmWE">https://t.co/pavDmbYmWE&lt;/a>&lt;/p>&amp;mdash; reo (@_uhzz_) &lt;a href="https://twitter.com/_uhzz_/status/1611374129810403331?ref_src=twsrc%5Etfw">January 6, 2023&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h3 id="202302">2023/02&lt;/h3>
&lt;h4 id="仕事-1">仕事&lt;/h4>
&lt;p>チームを異動してすぐに、翌月のリリースに向けた機能開発が始まりました。&lt;/p>
&lt;p>都度リードエンジニアに設計方針を確認しながら、のびのび開発できました。&lt;/p>
&lt;p>コミット量はこんなかんじ&lt;/p>
&lt;img src="https://uh-zz.github.io/posts/category/look-back-on/2023/12/24/contribute_2023_2.png"
alt="contribute in february"
width="500"
>
&lt;h4 id="副業">副業&lt;/h4>
&lt;p>前職で副業を始めました。&lt;/p>
&lt;p>正社員時代と同じチームに参加させていただくことができ、業務内容もバックエンド開発がメインです。&lt;/p>
&lt;h4 id="大学">大学&lt;/h4>
&lt;p>以下の科目習得試験を受験しました。&lt;/p>
&lt;ul>
&lt;li>Web アプリケーション&lt;/li>
&lt;li>離散数学&lt;/li>
&lt;li>Web 技術基礎&lt;/li>
&lt;/ul>
&lt;p>特に離散数学で扱うグラフ理論は、入学してから一番 Computer Science してるなと実感しました。&lt;/p>
&lt;h4 id="プライベート-1">プライベート&lt;/h4>
&lt;p>高校からの友人に結婚のご祝儀を渡しました。&lt;/p>
&lt;p>祝儀袋を買って、お金を包むイベントは初めてだったので、とても感慨深かったです。&lt;/p>
&lt;h3 id="202303">2023/03&lt;/h3>
&lt;h4 id="仕事-2">仕事&lt;/h4>
&lt;p>2 月に開発していた機能をリリースしました。&lt;/p>
&lt;p>詳細はこの後で触れるのですが、チームを異動して初めてのリリースでした。&lt;/p>
&lt;h4 id="プライベート-2">プライベート&lt;/h4>
&lt;p>軽井沢観光に行きました。&lt;/p>
&lt;p>長野出身の同僚に教えてもらって、旧軽井沢銀座通りやミカド珈琲を巡りました。&lt;/p>
&lt;p>個人的には、白糸の滝に行けたのが１つ思い出になりました。&lt;/p>
&lt;p>筆者撮影&lt;/p>
&lt;img src="https://uh-zz.github.io/posts/category/look-back-on/2023/12/24/shiraitonotaki.jpg"
alt="contribute in february"
width="500"
>
&lt;p>桜が綺麗ですね &amp;#x1f338;&lt;/p></description></item><item><title>2022年の振り返り</title><link>https://uh-zz.github.io/posts/category/look-back-on/2022/12/31/</link><pubDate>Sat, 31 Dec 2022 09:00:00 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/look-back-on/2022/12/31/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>１年経つのは早いですね。&lt;/p>
&lt;p>今年のサマリーとしては、通信大学へ入学したことと転職したこと、です。&lt;/p>
&lt;p>去年はこのブログの投稿を増やしていくと意気込んでいましたが実績は、、意気込みは大事なので来年も意気込んでいきます&amp;#x1f4aa;&lt;/p>
&lt;p>振り返りについては需要の有無に関わらず書いていきたいと思ってる所存です。&lt;/p>
&lt;h3 id="バックナンバー">バックナンバー&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://uh-zz.github.io/posts/category/look-back-on/2021/" target="_blank" rel="noopener">2021 年の振り返り&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="202201">2022/01&lt;/h2>
&lt;p>とくに話すトピックはありませんでした。&lt;/p>
&lt;p>新年一発目こそなにかあれよ！と自分でツッコミを入れたくなったので、意識的に１月にイベントつくっていきます&lt;/p>
&lt;h2 id="202202">2022/02&lt;/h2>
&lt;p>コロナの感染拡大がまた出てきたころで、予定されていた開発合宿がオンラインでの開催になりました&lt;/p>
&lt;p>&lt;a href="https://note.com/fukurou_dev/n/nc3edd15ccb78" target="_blank" rel="noopener">初のオンライン合宿開催！開発合宿についてご紹介！&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.gather.town/" target="_blank" rel="noopener">Gather&lt;/a>はこのとき初めて使いましたが、会議室に入ると強制的にビデオ通話になったりホワイトボードを共有したりと Google Meet や Zoom のような使い方ができるのに加え、マップを自分たちでつくったりゴーカートができたりと、息抜き要素があったのが推しポイントです。&lt;/p>
&lt;p>このとき気に入って、合宿のあともオンボーディングを Gather でやってたりもしたなぁと思い返したり&amp;#x1f60c;&lt;/p>
&lt;h2 id="202203">2022/03&lt;/h2>
&lt;p>とくに話すことはありませんでした。&lt;/p>
&lt;h2 id="202204">2022/04&lt;/h2>
&lt;p>ふらっと Kyash のイベントを見にいきました。&lt;/p>
&lt;p>&lt;a href="https://kyash.connpass.com/event/244819/" target="_blank" rel="noopener">Kyash TechTalk #2 - Serverside のシステム構成とアーキテクチャ&lt;/a>&lt;/p>
&lt;p>このとき、Kyash のサーバ構成を知れたのもそうですが、苦労話や課題に思っていることを対外的に発信しているのを見て、技術力求められそうだなというのと、中の人楽しそうに話してるなと思ったのを覚えています。&lt;/p>
&lt;p>このイベントのあと、メールでカジュアル面談のお誘いをもらったので、転職活動はしてなかったけど、興味本位でセッティングしてもらったのが今年の転職につながりました。&lt;/p>
&lt;p>またプライベートな話題としては、通信大学に入学しました&lt;/p>
&lt;p>&lt;a href="https://uh-zz.github.io/posts/category/look-back-on/2022/05/31/go-to-the-teikyo-university/" target="_blank" rel="noopener">【通信教育課程】帝京大学理工学部情報科学科に編入学しました&lt;/a>&lt;/p>
&lt;p>入ってから８ヶ月目で思うことは、年間 12 科目の単位を働きながら取るのは絶対ムリ！ではないかもしれませんが、ギリギリを攻めている感覚と怠惰な休日の時間を取りづらくなるということです。
これは勉強するリズムがついていいじゃないかという反面、興味が薄い科目に関して場当たり的な勉強をしてしまいがちなのと、休日を授業やレポートで埋めると休みが休みでなくなってしまう悲しみを少なからず感じるということです。&lt;/p>
&lt;p>この振り返りは、来年 2 月の区切りのいいところで改めて記事にしようと思います。&lt;/p>
&lt;h2 id="202205">2022/05&lt;/h2>
&lt;p>ジムに行き始めました。きっかけはリモートワークをしていて一日座ってる時間が長いと寝つきが悪かったりするので、体を動かしてぐっすり眠りたい、と思ったからです
。&lt;/p>
&lt;p>今も継続して週に 2 回くらいは走りに行ってます。&lt;/p>
&lt;p>走るマシン（トレッドミル）しか活用できてないので、来年はほかのトレーニングにも手を出したいです。&lt;/p>
&lt;h2 id="202206">2022/06&lt;/h2>
&lt;p>とくに話すことはありませんでした。&lt;/p>
&lt;h2 id="202207">2022/07&lt;/h2>
&lt;p>通信大学の初めての単位習得試験があり、物理的な会場での受験でした。&lt;/p>
&lt;p>内心なにかしら交流があるかも&amp;#x1f60c;、とそわそわしていましたが、杞憂に終わりました。&lt;/p>
&lt;h2 id="202208">2022/08&lt;/h2>
&lt;p>昨年から月 1 で参加していた&lt;a href="https://yshibata.blog.ss-blog.jp/2022-08-08" target="_blank" rel="noopener">『プログラミング言語 Go』オンライン読書会&lt;/a>が一区切りつきました。&lt;/p>
&lt;p>初めて参加した社外勉強会がこの読書会だったので、個人的に印象深く、毎回新しい知見を得る場として楽しませていただきました。&lt;/p>
&lt;p>今は柴田先生が主催するべつの読書会に参加していますが、相変わらず聞き専になってしまっているので、恥ずかしがらずに質問していくのを来年の抱負にしようと思います笑&lt;/p>
&lt;h2 id="202209">2022/09&lt;/h2>
&lt;p>今年は通信大学に入ったのを言い訳に、技術書以外の本を買ったり読んだりする機会が少なかったんですが、その中でも社会学のテキストが個人的に面白かったので、マイベストブックにノミネートしました。&lt;/p>
&lt;p>&lt;a href="http://www.yuhikaku.co.jp/books/detail/9784641053700" target="_blank" rel="noopener">社会学 新版 (New Liberal Arts Selection) &lt;/a>&lt;/p></description></item><item><title>netパッケージで非推奨のTemporaryメソッドの扱いについて</title><link>https://uh-zz.github.io/posts/category/go/2022/12/kyash-advent-calendar/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/go/2022/12/kyash-advent-calendar/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>こちらは&lt;a href="https://adventar.org/calendars/7407" target="_blank" rel="noopener">Kyash Advent Calendar 2022&lt;/a> の 13 日目の記事です。&lt;/p>
&lt;p>今年の 11 月に Kyash に入社しました！サーバサイドチームの&lt;a href="https://twitter.com/_uhzz_" target="_blank" rel="noopener">uehara&lt;/a>です&amp;#x1f44b;&lt;/p>
&lt;p>今回は&lt;code>net/http&lt;/code>パッケージの非推奨メソッドである&lt;code>Temporary()&lt;/code>について、社のメンバーから知見を共有してもらったのでその話をします。&lt;/p>
&lt;h2 id="nethttp-パッケージの-非推奨メソッド-temporary-について">net/http パッケージの 非推奨メソッド Temporary() について&lt;/h2>
&lt;p>&lt;code>Temporary()&lt;/code>については、フューチャー社の記事にわかりやすくまとめられています。&lt;/p>
&lt;p>&lt;a href="https://future-architect.github.io/articles/20220203a/" target="_blank" rel="noopener">https://future-architect.github.io/articles/20220203a/&lt;/a>&lt;/p>
&lt;p>上記の記事を踏まえて、ここでは非推奨になった経緯と対応について言及しようと思います。&lt;/p>
&lt;p>サッと概要を話すと、&lt;code>Temporary()&lt;/code>は&lt;code>net.Error&lt;/code>インターフェースに定義されているメソッドで、一時的なエラーかどうか判定するために用意されています。
ただし、「一時的」というのがうまく定義されていないとの理由で、こちらのメソッドは Go1.18 で非推奨になりました。&lt;/p>
&lt;blockquote>
&lt;p>net.Error.Temporary has been deprecated.
&lt;a href="https://tip.golang.org/doc/go1.18" target="_blank" rel="noopener">https://tip.golang.org/doc/go1.18&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="temporaryが非推奨になった経緯">Temporary()が非推奨になった経緯&lt;/h2>
&lt;p>前提として、&lt;code>net.Error&lt;/code>インターフェースは、以下のように定義されています
※ソースは Go 1.19 です&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// An Error represents a network error.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Error&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Timeout&lt;/span>() &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#75715e">// Is the error a timeout?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Deprecated: Temporary errors are not well-defined.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Most &amp;#34;temporary&amp;#34; errors are timeouts, and the few exceptions are surprising.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Do not use this method.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Temporary&lt;/span>() &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>非推奨になったときの issue を追ってみます&lt;/p></description></item><item><title>Futureパターンが使われているOSSを見てみた</title><link>https://uh-zz.github.io/posts/category/go/2022/12/qiita-advent-calender/</link><pubDate>Sat, 10 Dec 2022 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/go/2022/12/qiita-advent-calender/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>&lt;a href="https://twitter.com/_uhzz_" target="_blank" rel="noopener">@uh-zz&lt;/a>です！&lt;/p>
&lt;p>この記事は、&lt;a href="https://qiita.com/advent-calendar/2022/go" target="_blank" rel="noopener">Go Advent Calendar 2022&lt;/a>の 10 日目の記事になります！&lt;/p>
&lt;p>今年は、個人的に色々なことに挑戦した年だったなあと振り返るとともに、去年のアドベントカレンダーからもう１年経つのか〜という気持ちです&lt;/p>
&lt;p>この記事では、Go における Future パターンをご紹介できればと思います&lt;/p>
&lt;h2 id="future-パターンとは">Future パターンとは&lt;/h2>
&lt;blockquote>
&lt;p>あるメソッドを呼び出すとします。 もしもオブジェクトが、そのメソッドを実行できる状態なら、実行します。 でも、実行できない状態なら、将来実行できる状態になるまで待つようにしたいとします。 その時に使えるのがこの Future パターンです。 future は「未来」という意味です&lt;/p>
&lt;p>もう少し正確にお話しましょう。 単にあるクラスに 「実行できる状態になるまで待つ」 という機能を入れるわけではありません。 すでに存在しているクラスに一皮かぶせて、 「実行できる状態になるまで待てるような機能を追加する」 というのが Future パターンです。&lt;/p>
&lt;p>出典: &lt;a href="https://www.hyuki.com/dp/dpinfo.html#Future" target="_blank" rel="noopener">結城浩, Future パターン, デザインパターン紹介&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>上記の参考記事内では、Java をつかったマルチスレッドプログラミングで Future パターンが実装されています。&lt;/p>
&lt;p>引用箇所の説明がほぼすべてですが、イメージ図で補足するとこんな感じになります&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">flowchart LR
呼び出し元 --&amp;gt; Futureメソッド -- 実行できるようになるまで待つ --&amp;gt; 処理するメソッド
&lt;/code>&lt;/pre>&lt;p>呼び出し元と処理するメソッドの間に Future メソッドを挟むことで、Future メソッドがプロキシ的に働き、非同期的に処理するメソッドを実行できるようになっています。&lt;/p>
&lt;h2 id="go-だとこんなかんじにかけるらしい">Go だとこんなかんじにかけるらしい&lt;/h2>
&lt;p>以下の記事で &lt;code>Future/Promise&lt;/code>という説明書されています&lt;/p>
&lt;p>&lt;a href="https://ascii.jp/elem/000/001/486/1486902/" target="_blank" rel="noopener">https://ascii.jp/elem/000/001/486/1486902/&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">readFile&lt;/span>(&lt;span style="color:#a6e22e">path&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルを読み込み、その結果を返すFutureを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">promise&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// readFile とは別のゴルーチンでファイルを読み出す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">content&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">ReadFile&lt;/span>(&lt;span style="color:#a6e22e">path&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;read error %s\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(&lt;span style="color:#a6e22e">promise&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 約束を果たした
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">promise&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> string(&lt;span style="color:#a6e22e">content&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">promise&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">printFunc&lt;/span>(&lt;span style="color:#a6e22e">futureSource&lt;/span> &lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">chan&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 文字列中の関数一覧を返すFutureを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">promise&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// printFunc とは別のゴルーチンで文字列操作する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// futureSource は readFile で読みだしたファイルの中身です
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// readFile(ファイル読み込み)が完了して、 futureSource(=promise) に
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 中身が送信されるまでこの処理は実行されません
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">line&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">Split&lt;/span>(&lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">futureSource&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">HasPrefix&lt;/span>(&lt;span style="color:#a6e22e">line&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;func &amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> = append(&lt;span style="color:#a6e22e">result&lt;/span>, &lt;span style="color:#a6e22e">line&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 約束を果たした
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">promise&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">promise&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">futureSource&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">readFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;future_promise.go&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 一見、 readFile が実行されたあとに、すぐ printFunc が実行されるように見えます
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// しかし、 printFunc の引数(futureSource)がチャネルになっているので、
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// futureSourceが値を受信するまで関数内で、futureSource を使うことができない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// よって関数内で実行待ちが発生します
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">futureFuncs&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">printFunc&lt;/span>(&lt;span style="color:#a6e22e">futureSource&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// チャネル(futureFuncs)を受信するまでブロック
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">Join&lt;/span>(&lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">futureFuncs&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>※記事内にあるコードに、コメントを追記させていただきました。&amp;#x1f64f;&lt;/p></description></item><item><title>履修科目一覧をNotionでつくりました</title><link>https://uh-zz.github.io/posts/category/look-back-on/2022/09/04/preview-courses-at-teikyo-univ/</link><pubDate>Sun, 04 Sep 2022 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/look-back-on/2022/09/04/preview-courses-at-teikyo-univ/</guid><description>&lt;h2 id="ご連絡">ご連絡&lt;/h2>
&lt;p>4 月から通信大学での学習を始めて、もう少しで半年になります。&lt;/p>
&lt;p>節目というか、ちょっと時間ができたので、私が履修している科目一覧を Notion で管理しようと思い立ち、さくっと作ってみました。&lt;/p>
&lt;p>&lt;a href="https://billowy-seed-d7a.notion.site/709ba86ae18d43b5b7b4aa0e5b92f912?v=722bec42fbd746df8f307976937167ab" target="_blank" rel="noopener">科目一覧 - Notion&lt;/a>&lt;/p>
&lt;p>これから同じように学習される方の参考になれば幸いです。（私も諸先輩方のブログを見て、参考になったので恩返しできれば！）&lt;/p>
&lt;h2 id="近況">近況&lt;/h2>
&lt;p>元気にやっています&amp;#x1f44b;&lt;/p>
&lt;h2 id="備考">備考&lt;/h2>
&lt;p>表紙イラスト：&lt;a href="https://loosedrawing.com/" target="_blank" rel="noopener">Loose Drawing&lt;/a>&lt;/p></description></item><item><title>2022年07月に読んだ記事とか本とか</title><link>https://uh-zz.github.io/posts/category/inputs/2022/07/</link><pubDate>Tue, 05 Jul 2022 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/inputs/2022/07/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>読んだ記事とか本のリンクを張っておきます&lt;/p>
&lt;h2 id="読んだ記事">読んだ記事&lt;/h2>
&lt;p>&lt;a href="https://speakerdeck.com/iselegant/mindset-for-an-architect" target="_blank" rel="noopener">アーキテクトに求められるマインドとは / mindset for an architect&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>「少なくとも、最悪ではないアーキテクチャを狙う」&lt;/p>
&lt;/blockquote>
&lt;p>自分の中で新しい視点だった(常に選択肢の中で(世間的に)最善とされているものがいいという思考をしてる)&lt;/p>
&lt;blockquote>
&lt;p>「変更が容易であれば、最初から望ましいアーキテクチャを正確に設計しなければならないという、プレッシャーも少なくなる」&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://terurou.hateblo.jp/entry/2022/07/16/161845" target="_blank" rel="noopener">Re: スクラム開発チームと業務委託エンジニアの相性が最悪だと思っている&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.m3tech.blog/entry/2021/12/19/120000#Database-Rider" target="_blank" rel="noopener">Spring で快適な DB 疎通ユニットテストライフを送りたい&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>yaml、json、または csv などのファイルでテスト用データの事前投入や結果比較を容易にしてくれます&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Database RIder はテストメソッド単位で使用するデータファイルを指定できる&lt;/p>
&lt;/blockquote>
&lt;p>友達に教えてもらった。テストデータをコードと別で、テスト前後の比較も簡単にしてくれるのはすごい。&lt;/p>
&lt;p>&lt;a href="https://logmi.jp/tech/articles/326846" target="_blank" rel="noopener">「“楽しくないけどお金のためにやる人”はやはり伸びない」まつもとゆきひろ氏が説く“プログラマーに向いている人”&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://logmi.jp/tech/articles/326957" target="_blank" rel="noopener">「ノーコードによって仕事が奪われるイメージはない」まつもとゆきひろ × 高橋直大 × 楠正憲が語る、これからのプログラマーの仕事&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.usenix.org/system/files/atc22-vig.pdf" target="_blank" rel="noopener">Amazon DynamoDB: A Scalable, Predictably Performant, and Fully Managed NoSQL Database Service&lt;/a>&lt;/p>
&lt;p>まだよんでない&lt;/p>
&lt;p>&lt;a href="https://medium.com/@jaysonmulwa/domain-driven-design-simplified-a03c732401c9" target="_blank" rel="noopener">Domain-Driven Design Simplified.&lt;/a>&lt;/p>
&lt;p>まだよんでない&lt;/p>
&lt;h2 id="読んだ本">読んだ本&lt;/h2>
&lt;p>&lt;a href="https://www.amazon.co.jp/%E8%87%AA%E5%88%86%E3%81%AB%E6%B0%97%E3%81%A5%E3%81%8F%E5%BF%83%E7%90%86%E5%AD%A6-%E5%8A%A0%E8%97%A4-%E8%AB%A6%E4%B8%89/dp/4569649580" target="_blank" rel="noopener">自分に気づく心理学-加藤 諦三(著)&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.amazon.co.jp/Lean%E3%81%A8DevOps%E3%81%AE%E7%A7%91%E5%AD%A6-Accelerate-%E3%83%86%E3%82%AF%E3%83%8E%E3%83%AD%E3%82%B8%E3%83%BC%E3%81%AE%E6%88%A6%E7%95%A5%E7%9A%84%E6%B4%BB%E7%94%A8%E3%81%8C%E7%B5%84%E7%B9%94%E5%A4%89%E9%9D%A9%E3%82%92%E5%8A%A0%E9%80%9F%E3%81%99%E3%82%8B-impress-gear/dp/4295004901/ref=sr_1_1?keywords=lean%E3%81%A8devops%E3%81%AE%E7%A7%91%E5%AD%A6&amp;amp;qid=1658040624&amp;amp;s=books&amp;amp;sprefix=lean%2Cstripbooks%2C237&amp;amp;sr=1-1" target="_blank" rel="noopener">Lean と DevOps の科学[Accelerate] テクノロジーの戦略的活用が組織変革を加速する (impress top gear)-Nicole Forsgren Ph.D. (著), Jez Humble (著), Gene Kim (著), 武舎広幸 (翻訳), 武舎るみ (翻訳)&lt;/a>&lt;/p></description></item><item><title>【通信教育課程】帝京大学理工学部情報科学科に編入学しました</title><link>https://uh-zz.github.io/posts/category/look-back-on/2022/05/31/go-to-the-teikyo-university/</link><pubDate>Tue, 31 May 2022 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/look-back-on/2022/05/31/go-to-the-teikyo-university/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>表題の通り、今年の 4 月から帝京大学理工学部情報科学科の通信教育課程に 2 年次編入しました。&lt;/p>
&lt;p>そもそもの経緯と入るまでの話、入って 1 ヶ月経過した後の所感をまとめておきたいと思います。&lt;/p>
&lt;h2 id="きっかけ">きっかけ&lt;/h2>
&lt;h3 id="大学進学について">大学進学について&lt;/h3>
&lt;p>通信制大学へ進学したいと思ったのは今年に入ってからではなく、ここ 2 年くらい検討していました。&lt;/p>
&lt;p>当初は理工系ではなく、社会学/哲学に興味があり、その方面の勉強がしたいと漠然と考えていました。&lt;/p>
&lt;p>ただ 2 年の間、大学への入学を躊躇してたのは以下の理由がありました。&lt;/p>
&lt;ul>
&lt;li>通信制大学の卒業が難しい、また卒業率が低いといった情報を見て腰が重かった&lt;/li>
&lt;li>働きながら時間が取れない、平日のフルタイムかつ出社している場合、早朝か、仕事から帰ってきて勉強時間を確保する必要が出てくるので、リモートできないと厳しい&lt;/li>
&lt;li>とりあえず入門書を買って積んでおけば自分で勉強できるし、進学しなくてもいいのでは？と諦めムードを出していた&lt;/li>
&lt;/ul>
&lt;p>以上の理由から悩んでは忘れるを一人繰り返しては日々を過ごしていました。&lt;/p>
&lt;h3 id="キャリアについて考えるようになった">キャリアについて考えるようになった&lt;/h3>
&lt;p>そんな中、昨年末に以下の記事を拝見しました。&lt;/p>
&lt;p>&lt;a href="https://engineer-lab.findy-code.io/gfx" target="_blank" rel="noopener">生涯現役のソフトウェアエンジニアでありたい。IC（Individual Contributor）のキャリアパスがあると自覚するまで 10 年の軌跡&lt;/a>&lt;/p>
&lt;p>IC(Individual Contributor)というキャリアがあるのかというのと、記事中の主張から自分のキャリアについて振り返る様になりました。&lt;/p>
&lt;blockquote>
&lt;p>これまでのキャリアは前述のようにかなり行きあたりばったりでしたが、その中にも不動となる主軸が 2 つありました。(中略)&lt;/p>
&lt;p>1 つは「毎日楽しく開発したい」ということ。(中略)&lt;/p>
&lt;p>もう 1 つの軸は「選択肢を常に複数確保する」ことです。(中略)&lt;/p>
&lt;/blockquote>
&lt;p>この「毎日楽しく開発したい」は、私がエンジニアになりたいと思った動機「楽しく(刺激的に)生きたい」に通じるものがあり、IC というキャリアないしはテクニカルスキルをあげることで自分の幸福につながるのかという気づきがありました。&lt;/p>
&lt;p>遠回りのような近道のような、どちらとも言えないですが、自分で出した答えの１つが大学進学、それもコンピュータに関する学位を取得するということでした。&lt;/p>
&lt;p>ここについては自分の中で消化しきれていない部分もあるので、別の記事で改めて振り返ることにします。&lt;/p>
&lt;h3 id="帝京大学に決めたのはそこまで時間がかからなかった">帝京大学に決めたのはそこまで時間がかからなかった&lt;/h3>
&lt;p>フルタイムで働きながらコンピュータに関する学位が取得できる通信制大学は、調べた限りだと選択肢は限られました。&lt;/p>
&lt;p>また、同じくエンジニアとして働きながら勉強されている方のブログが大変参考になりました。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://gkzz.dev/posts/sophomore-voice/" target="_blank" rel="noopener">帝京大学理工学部(通信教育課程)の社会人大学生 1 年目をふりかえる&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://bnpb.hatenablog.com/entry/2019/05/26/135022" target="_blank" rel="noopener">帝京大学の通信教育課程の学生やってます&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>@gkzvoice さんには twitter でブログに関して質問させていただき、またアドバイスまでいただいたので感謝です。&lt;/p>
&lt;/blockquote>
&lt;h2 id="入るまでの手続きなど">入るまでの手続きなど&lt;/h2>
&lt;p>詳細な手続きは募集要項にあるので、ここでは所感を述べるだけにします。&lt;/p>
&lt;ul>
&lt;li>調査書、成績表の発行を、所属していた専門学校に依頼する必要があるので、余裕を持って出願する&lt;/li>
&lt;li>志望理由を記載する必要があるので、動機と抱負は棚卸ししてたほうがスムーズかも&lt;/li>
&lt;/ul>
&lt;h3 id="2-年次編入について">2 年次編入について&lt;/h3>
&lt;p>今回 2 年次編入で出願することができました。&lt;/p>
&lt;p>というのも、情報系専門学校の 2 年制を卒業しているので、編入の要件を満たしていたからというのが理由です。&lt;/p>
&lt;p>要件を満たしていれば、専門学校での授業内容がまとめられたシラバス？を願書と一緒に提出した後、大学にて専門学校の授業内容から、関連する大学側での科目が履修済みとして、認定されます。&lt;/p>
&lt;p>今回は認定された科目が上限数に達していたので、晴れて編入することができたのでした。&lt;/p>
&lt;h2 id="そして入学しました">そして入学しました&lt;/h2>
&lt;p>出願から約 2 ヶ月後、晴れて入学式を迎えることができました。&lt;/p></description></item><item><title>2021年の振り返り</title><link>https://uh-zz.github.io/posts/category/look-back-on/2021/</link><pubDate>Fri, 31 Dec 2021 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/look-back-on/2021/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>今年のふりかえりをするために個人ブログを数ヶ月ぶりに更新しています。&lt;/p>
&lt;p>しばらくぶりに拙ブログを見ていて、ぜんぜんメンテしてなかったや。。の反省を強く感じたので来年はアウトプットをもっともっと増やします！&lt;/p>
&lt;h2 id="202101">2021/01&lt;/h2>
&lt;p>とくに話すトピックはありませんでした。&lt;/p>
&lt;h4 id="読んでた本">読んでた本&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.amazon.co.jp/%E6%94%B9%E8%A8%822%E7%89%88-%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AEGo%E8%A8%80%E8%AA%9E-%E6%9D%BE%E6%9C%A8-%E9%9B%85%E5%B9%B8-ebook/dp/B07VPSXF6N/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=3K0IFIL672AXB&amp;amp;keywords=%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AEgo&amp;amp;qid=1640946090&amp;amp;sprefix=%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AEgo%2Caps%2C434&amp;amp;sr=8-1" target="_blank" rel="noopener">改訂 2 版 みんなの Go 言語&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.amazon.co.jp/Go%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E5%AE%9F%E8%B7%B5%E5%85%A5%E9%96%80-%E6%A8%99%E6%BA%96%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%A7%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89Web%E3%82%A2%E3%83%97%E3%83%AA%E3%82%92%E4%BD%9C%E3%82%8B-impress-gear%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-Sheong-Chang-ebook/dp/B06XKPNVWV/ref=sr_1_1?keywords=go%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E5%AE%9F%E8%B7%B5%E5%85%A5%E9%96%80&amp;amp;qid=1640942078&amp;amp;sprefix=go%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%2Caps%2C611&amp;amp;sr=8-1" target="_blank" rel="noopener">Go プログラミング実践入門　標準ライブラリでゼロから Web アプリを作る&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="202102">2021/02&lt;/h2>
&lt;p>とくに話すトピックはありませんでした。&lt;/p>
&lt;h4 id="読んでた本-1">読んでた本&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://www.amazon.co.jp/%E9%81%94%E4%BA%BA%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC-%E2%80%95%E7%86%9F%E9%81%94%E3%81%AB%E5%90%91%E3%81%91%E3%81%9F%E3%81%82%E3%81%AA%E3%81%9F%E3%81%AE%E6%97%85%E2%80%95-%E7%AC%AC2%E7%89%88-David-Thomas-ebook/dp/B08T9BXSVD/ref=sr_1_1?keywords=%E9%81%94%E4%BA%BA%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC&amp;amp;qid=1640942729&amp;amp;sprefix=%E9%81%94%E4%BA%BA%2Caps%2C316&amp;amp;sr=8-1" target="_blank" rel="noopener">達人プログラマー ―熟達に向けたあなたの旅― 第 2 版&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="202103">2021/03&lt;/h2>
&lt;p>このころから年内に引っ越しを考えはじめました。&lt;/p>
&lt;p>部屋に不満はありませんでしたが、ぼんやりと中央線沿い(=東京の西側)がかっこいいというイメージをもっていたので一人でちょくちょく出向いていました。&lt;/p>
&lt;p>主に、杉並区エリア(中野/高円寺/阿佐ヶ谷/荻窪)を中心にまわっていました。&lt;/p>
&lt;p>特に、荻窪にある&lt;a href="https://sam.or.jp/" target="_blank" rel="noopener">杉並アニメーションミュージアム&lt;/a>は、展示も楽しく見れますが、ミュージアムが入っている&lt;a href="https://www.city.suginami.tokyo.jp/shisetsu/katsudo/suginamikaikan/1007019.html" target="_blank" rel="noopener">杉並会館&lt;/a>の雰囲気が抜群にいいのでおすすめです。&lt;/p>
&lt;h2 id="202104">2021/04&lt;/h2>
&lt;p>転職しました。社会人４年目にして３社目になります。&lt;/p>
&lt;p>前職と同じくサーバーサイドのポジションです。&lt;/p>
&lt;p>前職では、コロナ以降フルリモートでしたが、転職後は週３出社になりました。&lt;/p>
&lt;p>出社になってからは、ランチをメンバーと取るようになり、コミュニケーションが増えたのがメリットに感じました。&lt;/p>
&lt;p>仕事に関して前職では主に、Java/Go/Node.js での開発を２年ほどしていましたが、転職直後は Ruby on Rails での開発がメインになりました。&lt;/p>
&lt;p>はじめての Ruby と Rails ということもあり、メンバーにはだいぶお世話になりながらも、プライベートではおすすめの参考書をかたっぱしから読む生活をしていました。&lt;/p>
&lt;h4 id="読んでた本-2">読んでた本&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%92%E7%9B%AE%E6%8C%87%E3%81%99%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AERuby%E5%85%A5%E9%96%80-%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98%E3%81%8B%E3%82%89%E3%83%86%E3%82%B9%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA%E3%83%BB%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E6%8A%80%E6%B3%95%E3%81%BE%E3%81%A7-Software-Design-plus%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/dp/4774193976" target="_blank" rel="noopener">プロを目指す人のための Ruby 入門 言語仕様からテスト駆動開発・デバッグ技法まで (Software Design plus シリーズ)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.amazon.co.jp/%E3%83%91%E3%83%BC%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88-Ruby-Rails-%E3%80%90%E5%A2%97%E8%A3%9C%E6%94%B9%E8%A8%82%E7%89%88%E3%80%91-Perfect/dp/4297114623/ref=sr_1_2?keywords=%E3%83%91%E3%83%BC%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88ruby&amp;amp;qid=1640941933&amp;amp;s=books&amp;amp;sprefix=%E3%83%91%E3%83%BC%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88ruby%2Cstripbooks%2C1928&amp;amp;sr=1-2" target="_blank" rel="noopener">パーフェクト Ruby on Rails 【増補改訂版】 (Perfect series)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.amazon.co.jp/%E3%83%AA%E3%83%BC%E3%83%80%E3%83%96%E3%83%AB%E3%82%B3%E3%83%BC%E3%83%89-%E2%80%95%E3%82%88%E3%82%8A%E8%89%AF%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F%E3%81%9F%E3%82%81%E3%81%AE%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%A7%E5%AE%9F%E8%B7%B5%E7%9A%84%E3%81%AA%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF-Theory-practice-Boswell/dp/4873115655/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=3FKLB5N1IRAWG&amp;amp;keywords=%E3%83%AA%E3%83%BC%E3%83%80%E3%83%96%E3%83%AB%E3%82%B3%E3%83%BC%E3%83%89&amp;amp;qid=1640952664&amp;amp;sprefix=%E3%83%AA%E3%83%BC%E3%83%80%E3%83%96%E3%83%ABk%2Caps%2C305&amp;amp;sr=8-1" target="_blank" rel="noopener">リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック (Theory in practice)&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="202105">2021/05&lt;/h2>
&lt;p>緊急事態宣言の期間に入り、ほぼフルリモートになりました。&lt;/p>
&lt;p>この頃のコミットを見てみると、主に Rails プロジェクトでのバグフィックスや、小さな機能追加をしていました。&lt;/p></description></item><item><title>達人プログラマーとは</title><link>https://uh-zz.github.io/posts/category/development/2021/03/pragmatic-programmer/</link><pubDate>Fri, 05 Mar 2021 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/development/2021/03/pragmatic-programmer/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>エンジニアとしてコードを書くようになって、もうすぐ２年というタイミングに差し掛かりました&lt;/p>
&lt;p>心境の変化としては、がむしゃらに毎日のタスクを通して「動く」コードを書くことから、メンテナンスしやすいコードを意識することが多くなりました&lt;/p>
&lt;p>「達人プログラマー」は、プログラマとして次のステップを踏み出そうというときにベストな一冊となっています&lt;/p>
&lt;h2 id="達人の哲学">達人の哲学&lt;/h2>
&lt;p>ソフトウェアのエントロピーの話は心当たりがありすぎた&lt;/p>
&lt;p>&lt;strong>エントロピー&lt;/strong> とは、物理学の用語で「ある系における無秩序の度合い」のことで、
時間が経つたびにエントロピーは増大していく&lt;/p>
&lt;p>ソフトウェアも同様に、時間が経つたびに無秩序になっていく&lt;/p>
&lt;p>これを &lt;strong>割れ窓理論&lt;/strong> というメカニズムで説明していたのもわかりやすかった&lt;/p>
&lt;p>窓が１枚割れているのを長期間放置しておくと、それをメンテナンスする気力もなくなるマインドが
植え付けられて、最終的には建物全体が破壊されていく&lt;/p>
&lt;p>ソフトウェアではこれを、悪い設計、誤った意思決定、質の悪いコードに見立てることができて、
放置しておくと潜在的なバグを生み出すことになりかねない&lt;/p>
&lt;p>こういった「割れた窓」を発見したと同時に速やかに修復するべきだ、そして時間がなくてもコメントを
残すといった何らかのアクションをしてくださいと言った主張だった&lt;/p>
&lt;p>茹でガエルの話は、ある程度精神的に余裕がないと気づくことが難しいと感じた&lt;/p>
&lt;p>あっつあつの熱湯にカエルを放り込むとびっくりして飛び出してくるが、
常温の水にカエルを入れて段々と温度をあげていくと、カエルは気づかないまま茹で上がると言った話&lt;/p>
&lt;p>要するに、いつも&lt;strong>メタ認知&lt;/strong>を意識して行動しようということ&lt;/p>
&lt;p>これは仕事に限らずしていきたい&lt;/p>
&lt;h2 id="達人のアプローチ">達人のアプローチ&lt;/h2>
&lt;p>章前半の&lt;strong>DRY 原則&lt;/strong>については膝を叩いて同意できるといった実感があった&lt;/p>
&lt;p>また、曳光弾の考え方については目からウロコだった&lt;/p>
&lt;p>複雑なシステムを構築していくときに、各機能を一つずつ作り込んでいくのではなく、各機能を最低限使えるようにするシンプルな箇所を探していくといった手法&lt;/p>
&lt;p>シンプルな箇所に最初に取り組んでその他は後回しにする（未実装）というのは初心者視点では至らないと感じた&lt;/p>
&lt;p>章後半のプロトタイプ、見積もりの話は現実でも問われることがあるものの、
実際に見積もりが大きく外れるような難しい設計をした経験がないということもあって実感が持てなかった&lt;/p>
&lt;blockquote>
&lt;p>「言語の制約はそれを使う人の世界を制限する」 - ヴィトゲンシュタイン&lt;/p>
&lt;/blockquote>
&lt;p>毎回トピックの初めに、名言があってモチベーションが上がる&lt;/p>
&lt;p>プログラミング言語に限らず、日常使っている日本語にも問題に対する考え方や
コミュニケーションに対する考え方に影響を及ぼしているという構造主義的な話もあって興味深い&lt;/p>
&lt;h2 id="基本的なツール">基本的なツール&lt;/h2>
&lt;blockquote>
&lt;p>「悩んでいる君、そしてその悩みの原因は他の誰でもない、君自身によるものだ」
ということを知るのはつらいものだ&lt;/p>
&lt;p>- ソフォクレス&lt;/p>
&lt;/blockquote>
&lt;p>デバッグの最初の心構え → &lt;strong>「パニクるな」&lt;/strong>&lt;/p>
&lt;h2 id="妄想の達人">妄想の達人&lt;/h2>
&lt;p>&lt;strong>契約プログラミング(DbC)&lt;/strong> は素晴らしい&lt;/p>
&lt;p>仕様を記述(契約)しておくことで、プログラマにバグになりかねないようなことをさせないプログラミングをする&lt;/p>
&lt;p>トラッシュ（メチャクチャ）にするのではなく、クラッシュ（停止）させる&lt;/p>
&lt;p>Go の&lt;code>if err != nil&lt;/code>で毎回エラーチェックしてるのはこれに則っているのかなと思った。&lt;/p>
&lt;p>確かに&lt;code>catch&lt;/code>で新しいエラーがくるたびに分類するのは怠い気もするかな、、&lt;/p>
&lt;h2 id="柳に雪折れなし">柳に雪折れなし&lt;/h2>
&lt;p>列車の衝突事故を例にして依存をわかりやすく説明している&lt;/p>
&lt;p>１つのメソッドであまりにも多くのことをやろうとすると、
連結されている全ての車両に影響が及ぶように、メソッドと属性が影響を受ける&lt;/p>
&lt;p>例)割引料金を算出するメソッドの中で、これらの操作を行う。&lt;/p>
&lt;ul>
&lt;li>顧客の注文履歴を参照する&lt;/li>
&lt;li>注文履歴から特定の注文オブジェクトを取得する&lt;/li>
&lt;li>注文オブジェクトの総額を返す&lt;/li>
&lt;li>総額から割引した値をオブジェクトにセットする&lt;/li>
&lt;/ul>
&lt;p>次のような考え方がある&lt;/p>
&lt;blockquote>
&lt;p>照会せずに依頼する
TDA(Tell, Don&amp;rsquo;t Ask)&lt;/p></description></item><item><title>OAuth について</title><link>https://uh-zz.github.io/posts/category/security/2021/01/oauth/</link><pubDate>Tue, 05 Jan 2021 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/security/2021/01/oauth/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;h2 id="oauth-とは">OAuth とは&lt;/h2>
&lt;p>ひとまず、&lt;a href="https://qiita.com/TakahikoKawasaki/items/e37caf50776e00e733be" target="_blank" rel="noopener">一番分かりやすい OAuth の説明&lt;/a>で大体の感覚がつかめますのでオススメです。&lt;/p>
&lt;p>こちらでもざっくり説明させてもらうと、OAuth は複数のアプリを連携させるための仕組みです。&lt;/p>
&lt;p>例えば、ブログの記事を更新した瞬間に、ブログから更新情報をツイートしたかったりする場合に使われます。&lt;/p>
&lt;p>ただ、そのままツイートできるわけではなくて、ブログアプリがツイートする許可(認可)をしてあげる必要があります。&lt;/p>
&lt;p>そして許可されたアプリは許可証(アクセストークン)を持っていることで、Twitter を使ってツイートできるという仕組みです。&lt;/p>
&lt;h3 id="メリット">メリット&lt;/h3>
&lt;p>OAuth を使うことで、上の例であげたブログアプリは、Twitter のユーザ名とパスワードを知らなくてもツイートできるという点です。&lt;/p>
&lt;p>巷のアプリはこれを使うことで、Google アカウントや Twitter など SNS アカウントを持っているだけでユーザ登録できちゃいます。最初の煩わしい登録の手間が省けて良いです。&lt;/p>
&lt;h2 id="oauth10">OAuth1.0&lt;/h2>
&lt;p>OAuth の初期バージョンです。他に 1.0a という名前のバージョンもありますが、Twitter では 1.0a を使うことができるみたいです。
(後述の 2.0 も同様に使用可)&lt;/p>
&lt;p>特徴としては、認証と署名を用いて実現される仕様でありますが、実装が複雑で使用する言語が限られてしまうというデメリット?があるみたいです。(堅牢ではあると思いますが)&lt;/p>
&lt;p>また、1.0 は Web アプリのみ対応しているので、デスクトップ/モバイルアプリは蚊帳の外とこれまた制限されるみたいです。&lt;/p>
&lt;p>(Twitter は Web アプリ以外でも使える xAuth という OAuth 拡張を開発したりしてたみたいです)&lt;/p>
&lt;p>さらに悲しいことに、1.0 の仕様は次の 2.0 の策定を持って廃止されたみたいです。&lt;/p>
&lt;h2 id="oauth20">OAuth2.0&lt;/h2>
&lt;p>後継です。複雑と言われていた署名(とトークン交換)をバッサリ省いています。&lt;/p>
&lt;p>これによって実装しやすいものになりましたがセキュリティが気になるところです。&lt;/p>
&lt;p>&lt;a href="https://qiita.com/TakahikoKawasaki/items/3600b28af7b63671b968" target="_blank" rel="noopener">OAuth 1.0 のほうが OAuth 2.0 より安全なの？&lt;/a>でも言われている通り、2.0 はクライアントアプリケーションの幅が広がった分、秘密鍵の隠蔽が難しくなるみたいです。。&lt;/p>
&lt;p>隠蔽できるかの違いはありますが、セキュリティレベルは両者それほど変わらないみたいです。&lt;/p>
&lt;p>(2.0 は経路を TLS 化していることで、1.0 よりも提示するパラメータが少なくなっているという事実はあるそうな)&lt;/p>
&lt;h2 id="まとめ">まとめ&lt;/h2>
&lt;p>実装のことを考えてこれからも 2.0 を使っていきましょうという締めです。&lt;/p></description></item><item><title>システム設計-part1-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;p>※&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener">現場で役立つシステム設計の原則&lt;/a>を元に記事を作成しています。&lt;/p>
&lt;h2 id="設計パターン">設計パターン&lt;/h2>
&lt;h3 id="値オブジェクトvalue-object">値オブジェクト(Value Object)&lt;/h3>
&lt;p>Java で変数を扱うとき、int や String などで型定義しがちな初心者丸出しの実装をしていた私ですが、値オブジェクトを知ったとき眼からウロコでした。&lt;/p>
&lt;p>値オブジェクトとは、汎用的な型(int や String)で型を定義するのではなく、&lt;strong>専用の&lt;/strong>型(クラスやインターフェース)を定義します。&lt;/p>
&lt;p>範囲の広い汎用的な型を使うのではなく、業務に合わせた値で制限するというものです。&lt;/p>
&lt;p>値オブジェクトクラスはこんなかんじ&lt;/p>
&lt;pre tabindex="0">&lt;code>class Quantity {
static final int MIN = 1;
static final int MAX = 100;
int value;
Quantity(int value) {
if (value &amp;lt; MIN) {
throw new IllegalArgumentException(&amp;#34;不正&amp;#34; + MIN + &amp;#34;未満&amp;#34;);
}
if (value &amp;gt; MAX) {
throw new IllegalArgumentException(&amp;#34;不正&amp;#34; + MAX + &amp;#34;超&amp;#34;);
}
this.value = value;
}
}
&lt;/code>&lt;/pre>&lt;p>そして参照はこんなかんじ&lt;/p>
&lt;pre tabindex="0">&lt;code>Quantity quantity = new Quantity(50);
&lt;/code>&lt;/pre>&lt;p>こうすることで Quantity 型は値の制限(0~100)付きの実装ができるので安全です。&lt;/p></description></item><item><title>システム設計-part2-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;p>※&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener">現場で役立つシステム設計の原則&lt;/a>を元に記事を作成しています。&lt;/p>
&lt;h2 id="設計パターン">設計パターン&lt;/h2>
&lt;h3 id="早期リターン">早期リターン&lt;/h3>
&lt;p>複雑になりがちな場合分けのロジックの見通しをよくしようというものです。&lt;/p>
&lt;p>&lt;strong>ありがちな&lt;code>if-else&lt;/code>をつなげた(例 1)&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Yen fee() {
Yen result;
if (isChild()) {
result = chidFee();
} else if (isSenior()) {
result = seniorFee();
} else {
result = adultFee();
}
return result;
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>さっきのコードからローカル変数を抜いて結果をすぐに&lt;code>return&lt;/code>するようにした(例 2)&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Yen fee() {
if (isChild()) {
return chidFee();
} else if (isSenior()) {
return seniorFee();
} else {
return adultFee();
}
}
&lt;/code>&lt;/pre>&lt;p>このように、値が決まるとすぐに&lt;code>return&lt;/code>するやり方を&lt;strong>早期リターン&lt;/strong>と言います。&lt;/p>
&lt;h3 id="ガード節">ガード節&lt;/h3>
&lt;p>&lt;strong>上記の例 2 から&lt;code>else&lt;/code>を抜いた(例 3)&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Yen fee() {
if (isChild()) return chidFee();
if (isSenior()) return seniorFee();
return adultFee();
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>else&lt;/code>を抜いた早期リターンを&lt;strong>ガード節&lt;/strong>と言います。非常にコンパクトですね。&lt;/p></description></item><item><title>システム設計-part3-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;p>※&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener">現場で役立つシステム設計の原則&lt;/a>を元に記事を作成しています。&lt;/p>
&lt;h2 id="業務ロジック">業務ロジック&lt;/h2>
&lt;h3 id="メソッドをロジックの置き場所にする">メソッドをロジックの置き場所にする&lt;/h3>
&lt;p>&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener">現場で役立つシステム設計の原則&lt;/a>では、&amp;ldquo;従来&amp;quot;という表現をされていますが、手続き型と呼ばれている設計ではデータクラスと機能クラスに分けて表現します。&lt;/p>
&lt;p>その名の通りデータクラスはデータを格納して、機能クラスはデータクラスのデータを判断、加工、計算するといった使い方です。&lt;/p>
&lt;p>この手続き型の問題は、拡張するときの変更箇所の特定に時間がかかるということです。&lt;/p>
&lt;p>なぜかというと、データクラスが参照できるクラスであれば、アーキテクチャのどのレイヤーにでもロジックが書けてしまうからです。&lt;/p>
&lt;p>便利のようには見えますが、先に言った変更箇所の特定に時間がかかるこの方法は最善ではありません。&lt;/p>
&lt;p>解決としては、Java 本来のクラスの使い方を踏襲することです。&lt;/p>
&lt;p>データとロジックを 1 つのクラスに閉じてしまおうという考え方です。&lt;/p>
&lt;pre tabindex="0">&lt;code>class PersonName {
private String firstName;
private String lastName;
String fullName() {
return String.format(&amp;#34;%s %s&amp;#34;, firstName, lastName);
}
}
&lt;/code>&lt;/pre>&lt;p>データである&lt;code>firstName&lt;/code>と&lt;code>lastName&lt;/code>、そしてロジック(メソッド)の&lt;code>fullName()&lt;/code>が同じクラス内にあります。&lt;/p>
&lt;p>こうするとクラス内でデータを扱うことができて変更もこのクラス内で閉じることができます。&lt;/p>
&lt;p>また、メソッドはクラス内のインスタンス変数(&lt;code>firstName&lt;/code>や&lt;code>lastName&lt;/code>)を使って何らかの処理を行う用途で作成します。&lt;/p>
&lt;h3 id="クラスが肥大化したら小さく分ける">クラスが肥大化したら小さく分ける&lt;/h3>
&lt;p>これもやってしまいがちですが、改修を繰り返していくうちに、クラスが大きくなっていきます。&lt;/p>
&lt;p>大きくなったクラスは手続き型同様に変更箇所の特定に時間がかかります。&lt;/p>
&lt;p>それを防ぐために、大きくなってしまったクラスを次のルールで細分化します。&lt;/p>
&lt;ul>
&lt;li>インスタンス変数とメソッドを対応付ける&lt;/li>
&lt;li>メソッドが全てのインスタンス変数を使うようになる&lt;/li>
&lt;/ul>
&lt;p>細分化したクラスはそれぞれ独立性が高くなるので、別のクラスで使う時にも再利用ができるようになります。&lt;/p>
&lt;p>こうした関連の強いデータとロジックをまとめたクラスを&lt;strong>凝集度が高い&lt;/strong>と言います。&lt;/p>
&lt;p>凝集度が高いクラスは、変更箇所もそのクラスに閉じることになるので、疎結合になり他への影響が少なくて済みます。&lt;/p>
&lt;h2 id="まとめ">まとめ&lt;/h2>
&lt;p>時すでに遅しと言いますか、現場での反省点をつらつら振り返ってベストプラクティスを学んでいるという感じです。&lt;/p>
&lt;p>次回に活かそうというモチベーションは上がるのでいい復習方法だと感じます。&lt;/p>
&lt;h2 id="備考">備考&lt;/h2>
&lt;p>&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener">現場で役立つシステム設計の原則&lt;/a>&lt;/p>
&lt;p>表紙イラスト：&lt;a href="https://loosedrawing.com/" target="_blank" rel="noopener">Loose Drawing&lt;/a>&lt;/p></description></item><item><title>スレッドと並行処理</title><link>https://uh-zz.github.io/posts/category/computer-science/2020/11/thread-and-concurrency/</link><pubDate>Mon, 05 Oct 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/computer-science/2020/11/thread-and-concurrency/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;h2 id="スレッド">スレッド&lt;/h2>
&lt;p>プロセスが最低１つは持っている実行単位のことです。&lt;/p>
&lt;p>こんな言い方をするのは、プロセスが複数のスレッドを管理できるからです。&lt;/p>
&lt;p>実行単位という視点でプロセスとの違いは、「アドレス空間」を共有できるという点です。&lt;/p>
&lt;p>尾を引くように&lt;a href="https://uh-zz.github.io/blog/posts/about-process/" target="_blank" rel="noopener">プロセス管理&lt;/a>の話に繋がりますが、プロセスにはそれぞれ１つのアドレス空間が割り当てられます。&lt;/p>
&lt;p>そして別のプロセスからアドレス空間へのアクセスは原則できません。(これを可能にするために共有メモリという方法を使います)&lt;/p>
&lt;p>それに対して、スレッドは１つのプロセスの実行単位を分けたものですから、同じアドレス空間を共有できるというわけです。&lt;/p>
&lt;p>そういうわけで、スレッドとプロセスをそれぞれ複数起動する場合は、スレッドの方がアドレス空間を１つで済ませることができるため省コストになります。&lt;/p>
&lt;p>では、複数のスレッドを起動してやることは?というと並行処理です。&lt;/p>
&lt;h2 id="並行処理">並行処理&lt;/h2>
&lt;p>これもすでに出てきている話ではあります。&lt;a href="https://uh-zz.github.io/blog/posts/about-process/" target="_blank" rel="noopener">プロセス管理&lt;/a>の記事で出した複数アプリを同時に起動させるという部分です。&lt;/p>
&lt;p>「同時に」というのは私たちユーザがそう解釈しているだけで、アプリは&lt;strong>カーネル&lt;/strong>が割り当てた非常に短い処理時間ごとに切り替えているのでしたよね。これが&lt;strong>並行処理&lt;/strong>です。&lt;/p>
&lt;p>スレッドでも同じように短い処理時間ごとに切り替えて「同時に」処理させることができます。&lt;/p>
&lt;h3 id="並列処理との違い">並列処理との違い&lt;/h3>
&lt;p>私自身、再三調べては納得 → 忘れるを繰り返していましたが、&lt;a href="https://uh-zz.github.io/blog/posts/about-process/" target="_blank" rel="noopener">プロセス管理&lt;/a>(3 度目)をまとめることでやっと理解できたと思います。&lt;/p>
&lt;p>並行処理では処理時間ごとに切り替えると言いましたが、並列処理では CPU １つは言わず２つで処理してしまえばいいじゃないという考え方です。&lt;/p>
&lt;p>図で見ると非常にわかりやすいのですが、並行処理だとパン食べてチーズ食べてハム食べてレタス食べて、、を繰り返して食べ切る作戦なのに対して、並列処理はミックスサンドとして食べ切るようなイメージです。&lt;/p>
&lt;p>そんなの絶対ミックスサンドとして処理したら無限じゃんと思われますが、並列処理にも上限があるようです。&lt;/p>
&lt;blockquote>
&lt;p>アムダールの法則といって複数のプロセッサ(CPU のことですね)を使って並列化による高速化を行う場合、そのプログラムの中で逐次的に実行される処理部分(並列)の時間によって、高速化が制限されるというものです。&lt;/p>
&lt;p>出典：&lt;a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%A0%E3%83%80%E3%83%BC%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87" target="_blank" rel="noopener">wikipedia「アムダールの法則」より引用&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>まあ、上限があるといっても高速するのに変わりはないわけです。&lt;/p>
&lt;p>今回はその中でも比較的面白い実装を見つけたのでそれを紹介します。&lt;/p>
&lt;h2 id="ワーカープール">ワーカープール&lt;/h2>
&lt;p>スレッドプールとも呼ばれるものです。並行処理でたくさんのスレッドを起動して、、というのももちろん可能ですが、それには代償が伴います。&lt;/p>
&lt;p>ワーカープールはそのようにいくつもスレッドを起動させるのではなく、すでに起動したスレッドを使い回そうの精神で実装される並行処理です。&lt;/p>
&lt;p>以下のような実装です。&lt;/p>
&lt;p>&lt;a href="https://oohira.github.io/gobyexample-jp/worker-pools.html" target="_blank" rel="noopener">こちら&lt;/a>を参考にさせていただきました。&lt;/p>
&lt;p>(ほぼコメントつけただけですが)&lt;/p>
&lt;pre tabindex="0">&lt;code>package main
import (
&amp;#34;fmt&amp;#34;
&amp;#34;time&amp;#34;
)
// 使い回し用のワーカー
func worker(id int, jobs &amp;lt;-chan int, results chan&amp;lt;- int) {
for j := range jobs {
fmt.Println(&amp;#34;worker&amp;#34;, id, &amp;#34;started job&amp;#34;, j)
time.Sleep(time.Second) // 1秒待ち(重い処理を想定)
fmt.Println(&amp;#34;worker&amp;#34;, id, &amp;#34;finished job&amp;#34;, j)
results &amp;lt;- j * 2
}
}
func main() {
// タスクの数
const numJobs = 5
// こなさなければいけないタスク
jobs := make(chan int, numJobs)
// タスクの成果物
results := make(chan int, numJobs)
for w := 1; w &amp;lt;= 3; w++ {
// 使い回し用のワーカーだけ生成しておく(この状態ではまだタスクをもらってないのでブロック)
go worker(w, jobs, results)
}
// タスク数だけjobsに渡す
for j := 1; j &amp;lt;= numJobs; j++ {
// チャネルへの書き込みを契機にワーカー起動
jobs &amp;lt;- j
}
// タスク数だけ格納されたらチャネルを閉じる
close(jobs)
for a := 1; a &amp;lt;= numJobs; a++ {
&amp;lt;-results
}
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>// 結果
worker 3 started job 1
worker 1 started job 2
worker 2 started job 3
worker 3 finished job 1
worker 3 started job 4
worker 1 finished job 2
worker 1 started job 5
worker 2 finished job 3
worker 1 finished job 5
worker 3 finished job 4
&lt;/code>&lt;/pre>&lt;p>実行するとわかりますが、順番がごっちゃになって処理されているのがわかります。&lt;/p></description></item><item><title>メモリ管理</title><link>https://uh-zz.github.io/posts/category/computer-science/2020/10/memory-management/</link><pubDate>Mon, 05 Oct 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/computer-science/2020/10/memory-management/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;h2 id="仮想メモリ">仮想メモリ&lt;/h2>
&lt;p>&lt;a href="https://uh-zz.github.io/blog/posts/about-process/" target="_blank" rel="noopener">プロセス管理&lt;/a>でもあったように、メモリはアドレス空間ごとにプロセスを管理します。&lt;/p>
&lt;p>アドレス空間は 4KB/8KB 単位の&lt;strong>ページ&lt;/strong>に分割して管理されています。&lt;/p>
&lt;p>ページはそれぞれ論理アドレス、物理アドレスを対応づける単位でもあります。&lt;/p>
&lt;p>論理アドレスと物理アドレスは常に紐づけられているわけではなく、そのページが必要になった時点で割り当てることも可能です。&lt;/p>
&lt;p>そのため、論理アドレスを実際の物理アドレスの容量より大きく確保することができます。&lt;/p>
&lt;p>(実際に使えるメモリの量よりも大きなメモリを想定できるということです。)&lt;/p>
&lt;p>仮装メモリとして使う仕組みには次の３つが挙げられます。&lt;/p>
&lt;h2 id="ページング">ページング&lt;/h2>
&lt;p>仮想メモリといえばこれ、という風に教えられるものの筆頭かと思います。&lt;/p>
&lt;p>ハードディスクを物理メモリの代わりに使うといったものです。&lt;/p>
&lt;p>物理メモリが不足すると、OS のコアである&lt;strong>カーネル&lt;/strong>は使われていないページをハードディスクに移して論理アドレスを解放します。&lt;/p>
&lt;p>そしてプロセスがハードディスクに移されたページにアクセスしようとすると、カーネルがプロセスを停止し、ハードディスクのページを再度物理メモリに読み込み、論理アドレスを対応づけます。&lt;/p>
&lt;p>また、プロセス全体を単位にする場合は&lt;strong>スワッピング&lt;/strong>と呼ばれます。&lt;/p>
&lt;h2 id="メモリマップトファイル">メモリマップトファイル&lt;/h2>
&lt;p>ファイルをメモリとしてアクセスすることができるものです。&lt;/p>
&lt;p>アクセスがあった瞬間に、カーネルがファイルをメモリに読み込みます。プロセスがメモリを使い終わると、論理アドレスと物理アドレスを解放して、メモリの内容をファイルに保存します。&lt;/p>
&lt;h2 id="共有メモリ">共有メモリ&lt;/h2>
&lt;p>１つの物理アドレスを、複数のプロセスの論理アドレスに対応づけるものです。
アドレス空間をまたぐと危険では？！という見方もありますが、複数プロセスで処理できるため、巨大な画像データを編集するときには都合が良いみたいです。&lt;/p>
&lt;p>※Go では共有メモリを使わずに Message Passing を使っています。&lt;/p>
&lt;h2 id="メモリ管理-api">メモリ管理 API&lt;/h2>
&lt;h3 id="malloc3">malloc(3)&lt;/h3>
&lt;p>メモリを&lt;strong>ヒープ領域&lt;/strong>に割り当てます。プログラム実行時に決まるサイズのメモリはヒープ領域から確保します。&lt;/p>
&lt;p>ヒープは「何かを積み重ねた山」のことで、その名の通り、プログラムを実行してから決定する量だけメモリを確保しておく領域なので納得です。&lt;/p>
&lt;p>malloc で確保したメモリは&lt;a href="#free">free&lt;/a>で解放しなければいけません。&lt;/p>
&lt;h3 id="calloc3">calloc(3)&lt;/h3>
&lt;p>メモリをヒープ領域に割り当てます。malloc と異なる点は、割り当てたメモリをゼロクリアすることです。&lt;/p>
&lt;p>こちらも malloc 同様、確保したメモリは&lt;a href="#free">free&lt;/a>で解放しなければいけません。&lt;/p>
&lt;h3 id="realloc3">realloc(3)&lt;/h3>
&lt;p>malloc で割り当てたメモリのサイズを拡大、縮小します。こちらも確保したメモリは&lt;a href="#free">free&lt;/a>で解放しなければいけません。&lt;/p>
&lt;h3 id="free">free&lt;/h3>
&lt;p>割り当てたメモリを開放します。いったん開放したアドレスにはアクセスしてはいけません。&lt;/p>
&lt;p>メモリの開放漏れを防ぐために、malloc で確保したメモリは常に free で開放されるべきです。&lt;/p>
&lt;h3 id="brk2">brk(2)&lt;/h3>
&lt;p>malloc や realloc が割り当てるためのメモリを探してくるものです。&lt;/p>
&lt;p>物理アドレスが割り当てられていないページに物理アドレスを対応づけます。&lt;/p>
&lt;h3 id="余談">余談&lt;/h3>
&lt;p>メモリはエラーでもかなりお世話になる部分なので、次回以降、実際のエラーやプログラミング言語(Go か Java)に絡めた記事を書きたいです。&lt;/p>
&lt;h2 id="備考">備考&lt;/h2>
&lt;p>&lt;a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E7%AC%AC2%E7%89%88-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797386479" target="_blank" rel="noopener">ふつうの Linux プログラミング 第 2 版 Linux の仕組みから学べる gcc プログラミングの王道&lt;/a>&lt;/p></description></item><item><title>Semantic Versioning</title><link>https://uh-zz.github.io/posts/category/oss/2020/08/semantic-versioning/</link><pubDate>Wed, 05 Aug 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/oss/2020/08/semantic-versioning/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;h2 id="セマンティックバージョニング">セマンティックバージョニング？&lt;/h2>
&lt;p>アプリに振るバージョン番号を&lt;a href="https://semver.org/lang/ja/" target="_blank" rel="noopener">SemVer&lt;/a>というルールに従って付与しましょうというものです。&lt;/p>
&lt;p>確かにバージョン番号に意味を持たせることで、ユーザからもアプリのバージョン番号が上がればバグ修正なのか機能追加なのかわかりますし、プログラムからも互換性を考慮して処理を分けることができるのでよいですね。&lt;/p>
&lt;h2 id="これだけ覚えておけば-ok">これだけ覚えておけば OK&lt;/h2>
&lt;p>バージョン番号の形式は、&lt;code>メジャー.マイナー.パッチ&lt;/code>です。(例：&lt;code>1.0.0&lt;/code>)&lt;/p>
&lt;h4 id="メジャー">メジャー&lt;/h4>
&lt;ul>
&lt;li>後方互換性がない変更があった時にはこの番号を上げなければいけません(MUST)&lt;/li>
&lt;li>この番号を上げた際には、マイナー/パッチの番号は 0 にリセットしなければいけません(MUST)&lt;/li>
&lt;li>この番号が「0」の場合は初期開発用として扱います。リリースの段階でこの番号を「1」に上げます。&lt;/li>
&lt;/ul>
&lt;h4 id="マイナー">マイナー&lt;/h4>
&lt;ul>
&lt;li>後方互換性を保ちつつ、機能追加のある時にはこの番号を上げなければいけません(MUST)&lt;/li>
&lt;li>この番号を上げた際には、パッチの番号は 0 にリセットしなければいけません(MUST)&lt;/li>
&lt;/ul>
&lt;h4 id="パッチ">パッチ&lt;/h4>
&lt;ul>
&lt;li>後方互換性を保ちつつ、バグ修正のある時にはこの番号を上げなければいけません(MUST)&lt;/li>
&lt;/ul>
&lt;p>※バグ修正とは間違った振る舞いを修正する内部の変更のことをいいます。&lt;/p>
&lt;h2 id="ちょっと踏み込むと">ちょっと踏み込むと&lt;/h2>
&lt;ul>
&lt;li>プレリリースバージョンには、パッチ番号の後ろにハイフンで区切って識別子をつけることができます。&lt;/li>
&lt;/ul>
&lt;p>(例：&lt;code>1.1.0-alpha / 1.1.0-beta / 1.1.0-rc&lt;/code>)
※ちなみに識別子の&lt;code>rc&lt;/code>は「release candidate」の略でベータ版よりもさらに製品版に近い品質のバージョンにつけるそうです。（略を初めて知りました。）&lt;/p>
&lt;ul>
&lt;li>あと npm の packagge.json でもモジュールをセマンティックバージョンで管理してます。（&lt;code>~&lt;/code>や&lt;code>^&lt;/code>が付与されているのをよく見ると思います。）&lt;/li>
&lt;/ul>
&lt;p>これについては&lt;a href="https://qiita.com/takayukioda/items/cb55d3f433af611295a5" target="_blank" rel="noopener">上、真ん中、下で覚えるバージョニング範囲指定&lt;/a>がわかりやすかったので共有しておきます。&lt;/p>
&lt;h2 id="余談">余談&lt;/h2>
&lt;p>たかがバージョニング、されどバージョニングといった感じでした。知ってて損はないですよね。&lt;/p>
&lt;h2 id="備考">備考&lt;/h2>
&lt;p>表紙イラスト：&lt;a href="https://loosedrawing.com/" target="_blank" rel="noopener">Loose Drawing&lt;/a>&lt;/p></description></item><item><title>球面三角法による２点間の距離計算をGoで実装してみた</title><link>https://uh-zz.github.io/posts/category/go/2020/07/spherical-trigonometry/</link><pubDate>Mon, 06 Jul 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/go/2020/07/spherical-trigonometry/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;p>地球上の２点間の距離計算ってアプリだと Google Map API を使えば完了！だと思いますが、どう計算してるかって気になりますよね？&lt;/p>
&lt;p>今回は球面三角法を利用した地球上の２点間の距離計算を Go で実装します。（調べたらフツーにあるんですが）&lt;/p>
&lt;h2 id="球面三角法とは">球面三角法とは&lt;/h2>
&lt;p>その名の通り、三角関数を利用して球面上の辺や角の大きさを導出するものです。平面と球面とでの違いは辺の大きさが
球面では中心角によって表されることにあります。&lt;/p>
&lt;p>よって、球面三角法を使用して算出した弧の長さ(中心角)と赤道の半径を乗算すると距離が求まります。&lt;/p>
&lt;p>球面三角法の証明については、&lt;a href="http://horibe.jp/PDFBOX/SphericalTriangles.pdf" target="_blank" rel="noopener">球面三角形の定理&lt;/a>を参考にしました！&lt;/p>
&lt;p>(&amp;ldquo;高校生に向けて&amp;quot;とある通り、非常にわかりやすかったです)&lt;/p>
&lt;p>球面三角法の余弦定理を利用して実際に距離を算出する方法は&lt;a href="https://qiita.com/port-development/items/eea3a0a225be47db0fd4#%E7%90%83%E9%9D%A2%E4%B8%89%E8%A7%92%E6%B3%95%E3%81%AE%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">球面三角法の余弦定理&lt;/a>がわかりやすいです。&lt;/p>
&lt;h2 id="実装">実装&lt;/h2>
&lt;p>実装したソースコードは Github でも確認できます。&lt;/p>
&lt;p>&lt;a href="https://github.com/uh-zz/traning/tree/master/algorithm/distance" target="_blank" rel="noopener">球面三角法を利用した２点間の距離計算&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>package main
import &amp;#34;math&amp;#34;
// Coordinate 緯度経度
type Coordinate struct {
Longitude float64
Latitude float64
}
// EarthRadius 赤道半径
const EarthRadius = 6378140
// DistanceOnTheEarth 地球上の 2 点間の距離を出す（球面三角法）
func DistanceOnTheEarth(from, to Coordinate) float64 {
fromLadLon := from.Longitude * math.Pi / 180
fromLadLat := from.Latitude * math.Pi / 180
toLadLon := to.Longitude * math.Pi / 180
toLadLat := to.Latitude * math.Pi / 180
alpha := math.Sin(fromLadLat)*math.Sin(toLadLat) +
math.Cos(fromLadLat)*math.Cos(toLadLat)*math.Cos(fromLadLon-toLadLon)
arcAlpha := math.Acos(alpha)
return arcAlpha * EarthRadius / 1000
}
&lt;/code>&lt;/pre>&lt;h2 id="動かしてみる">動かしてみる&lt;/h2>
&lt;p>それでは実装した Go の関数を呼び出す簡単なアプリを動かしていきます。&lt;/p></description></item><item><title>ソートアルゴリズムをGoで実装してみた</title><link>https://uh-zz.github.io/posts/category/go/2020/07/compare-sort-aligorithm/</link><pubDate>Sun, 05 Jul 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/go/2020/07/compare-sort-aligorithm/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;h2 id="マージソート">マージソート&lt;/h2>
&lt;blockquote>
&lt;p>マージソートは、ソートのアルゴリズムで、既に整列してある複数個の列を 1 個の列にマージする際に、小さいものから先に新しい列に並べれば、新しい列も整列されている、というボトムアップの分割統治法による。大きい列を多数の列に分割し、そのそれぞれをマージする作業は並列化できる。&lt;/p>
&lt;p>出典：&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88#:~:text=%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AF%E3%80%81%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AE,%E4%BD%9C%E6%A5%AD%E3%81%AF%E4%B8%A6%E5%88%97%E5%8C%96%E3%81%A7%E3%81%8D%E3%82%8B%E3%80%82" target="_blank" rel="noopener">wikipedia「マージソート」より引用&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>最悪の計算量が O(n log n) であるから少なくとも O(n^2)よりは速いんだろうなという印象（雑すぎるか）&lt;/p>
&lt;p>以下「&lt;a href="https://qiita.com/drken/items/44c60118ab3703f7727f" target="_blank" rel="noopener">ソートを極める！ 〜 なぜソートを学ぶのか 〜&lt;/a>」を元に実装してみた（なるべくソースを見ないで実装を試みたがマージする箇所は折れた、、）&lt;/p>
&lt;pre tabindex="0">&lt;code>package main
import (
&amp;#34;fmt&amp;#34;
&amp;#34;time&amp;#34;
&amp;#34;github.com/uh-zz/traning/algorithm/shuffle&amp;#34;
)
func main() {
// ランダムな要素 n 個のスライス取得
input := shuffle.RandomIntList(n)
inputLength := len(input)
// マージソート
MergeSort(&amp;amp;input, 0, inputLength)
}
// MergeSort マージソート
func MergeSort(input \*[]int, left, right int) {
// 要素数1つの場合は抜ける
if right-left == 1 {
return
}
// 配列を２つに分けるインデックス
middle := left + (right-left)/2
// 配列左側
MergeSort(input, left, middle)
// 配列右側
MergeSort(input, middle, right)
var buffer []int
// 左側と右側をバッファにためる（右側反転）
for index := left; index &amp;lt; middle; index++ {
buffer = append(buffer, (*input)[index])
}
for index := right - 1; index &amp;gt;= middle; index-- {
buffer = append(buffer, (*input)[index])
}
// マージする
scopeLeft := 0
scopeRight := len(buffer) - 1
for index := left; index &amp;lt; right; index++ {
if buffer[scopeLeft] &amp;lt;= buffer[scopeRight] {
// 左側採用
(*input)[index] = buffer[scopeLeft]
scopeLeft++
} else {
// 右側採用
(*input)[index] = buffer[scopeRight]
scopeRight--
}
}
}
&lt;/code>&lt;/pre>&lt;p>これ考えたのぶっ飛んでるなあと思って Wikipedia 見てたら、考案者が&lt;a href="https://ja.wikipedia.org/wiki/%E3%82%B8%E3%83%A7%E3%83%B3%E3%83%BB%E3%83%95%E3%82%A9%E3%83%B3%E3%83%BB%E3%83%8E%E3%82%A4%E3%83%9E%E3%83%B3" target="_blank" rel="noopener">フォン・ノイマン&lt;/a>でやっぱりぶっ飛んでた（凄すぎ）&lt;/p></description></item><item><title>プロセス管理</title><link>https://uh-zz.github.io/posts/category/computer-science/2020/09/process-management/</link><pubDate>Sun, 05 Jul 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/computer-science/2020/09/process-management/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;h2 id="プロセスとは">プロセスとは&lt;/h2>
&lt;p>プロセスという概念は Linux において、ファイルシステム、ストリームに並んで重要な構成要素の１つです。&lt;/p>
&lt;p>プログラマが作成したソースコードはファイルに保存されます。そしてファイルの保存先はハードディスクです。&lt;/p>
&lt;p>プログラムの実行時、プログラムはハードディスクからメモリへと読み込まれます。&lt;/p>
&lt;p>CPU はメモリに読み込まれたプログラムを順次処理していきます。このとき、メモリに読み込まれて CPU に処理されているプログラムを&lt;strong>プロセス&lt;/strong>といいます。&lt;/p>
&lt;p>１つのプロセスを処理できるのは１つの CPU のみです。&lt;/p>
&lt;p>そのため、同じプロセスしか一度に実行できなくなるといったことを避けるために、CPU はプロセスごとに処理時間を決めて次々に切り替えます。&lt;/p>
&lt;p>普段使っている PC やスマホは Youtube や Line や Twitter など、複数アプリを同時に起動して使用しています。&lt;/p>
&lt;p>あれは CPU が処理時間を決めて順に処理しているために実現されています。&lt;/p>
&lt;p>OS のコアである&lt;strong>カーネル&lt;/strong>はプロセスの優先順位を考慮して、各プロセスに処理時間を割り当てます。&lt;/p>
&lt;p>(この機能を&lt;strong>スケジューラ&lt;/strong>、または&lt;strong>ディスパッチャ&lt;/strong>といいます。)&lt;/p>
&lt;h2 id="アドレス空間">アドレス空間&lt;/h2>
&lt;p>プロセス１つに対して、CPU とメモリがそれぞれ１つ必要です。CPU は前述の通り、処理時間を割り当てるのに対し、メモリはプロセスごとに&lt;strong>アドレス空間&lt;/strong>を割り当てます。&lt;/p>
&lt;p>メモリにプログラムを書き込む際には&lt;strong>アドレス&lt;/strong>が必要です。&lt;/p>
&lt;p>しかしプロセスには 0 番地から始まるメモリが必要なため、１つのプロセスしか使えなくなってしまいます。&lt;/p>
&lt;p>そこでプロセスから見えるアドレス(&lt;strong>論理アドレス&lt;/strong>)と実際のアドレス(&lt;strong>物理アドレス&lt;/strong>)を分けてしまいます。&lt;/p>
&lt;p>こうすることで、カーネルと CPU によって論理アドレス → 物理アドレスと変換された実際のアドレスに対して書き込むことができます。&lt;/p>
&lt;p>１つのプロセスの論理アドレス、物理アドレスを全体として&lt;strong>アドレス空間&lt;/strong>といいます。&lt;/p>
&lt;p>アドレス空間はプロセスごとに割り当てられるので他のプロセスにアクセスできなくなります。&lt;/p>
&lt;h2 id="プロセス-api">プロセス API&lt;/h2>
&lt;h3 id="fork2">fork(2)&lt;/h3>
&lt;p>自分のプロセスを複製して新しいプロセスを作ります。&lt;/p>
&lt;p>Github でも fork がありますが、意味合いは同じです。既存のリポジトリを複製します。複製したリポジトリは自由に更新できますが、fork した元のリポジトリに対しては更新はできません。&lt;/p>
&lt;p>プロセスの fork は元からあるプロセスを&lt;strong>親プロセス&lt;/strong>、複製されたプロセスを&lt;strong>子プロセス&lt;/strong>と呼びます。&lt;/p>
&lt;p>子プロセスの fork 実行時の戻り値は 0 です。&lt;/p>
&lt;p>(戻り値 0 は正常終了のステータスコード)そして親プロセスの fork 実行時の戻り値は子プロセスのプロセス ID です。&lt;/p></description></item><item><title>DynamoDB のソートキーだけで絞り込みたいとき</title><link>https://uh-zz.github.io/posts/category/aws/2020/06/dynamo-only-sortkey-without-partionkey/</link><pubDate>Fri, 05 Jun 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/aws/2020/06/dynamo-only-sortkey-without-partionkey/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>Dynamo のテーブルに GSI(グローバルセカンダリインデックス)を貼ってハッシュキー＋ソートキーでクエリするパターンが通常の使い方かと思います。&lt;/p>
&lt;p>ではソートキーを日付にしていた場合、同じ日付範囲のデータを一括で取得できる方法はありますでしょうか？&lt;/p>
&lt;p>公式ドキュメントにはその辺の Tips なかったのですが、同僚から以下の記事を教えてもらいました。&lt;/p>
&lt;p>&lt;a href="https://www.ketancho.net/entry/2018/01/30/075500#%E8%A8%AD%E8%A8%88%EF%BC%92%E3%83%80%E3%83%9F%E3%83%BC%E5%88%97%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E3%82%BB%E3%82%AB%E3%83%B3%E3%83%80%E3%83%AA%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%82%92%E8%B2%BC%E3%82%8B%E6%A1%88" target="_blank" rel="noopener">DynamoDB の設計力をあげたい&lt;/a>&lt;/p>
&lt;p>これの設計２を参考にしました。&lt;/p>
&lt;p>全データ共通のダミー列を用意して、以下の GSI を作成します。&lt;/p>
&lt;ul>
&lt;li>パーティションキーはダミー列&lt;/li>
&lt;li>ソートキーに日付&lt;/li>
&lt;/ul>
&lt;p>これで同じ日付範囲の複数データを引っ張ってくることが可能になります。&lt;/p>
&lt;p>確かに美しいと言えないかもしれませんが、機転の効いた方法だと思いました。&lt;/p></description></item><item><title>アジャイル開発</title><link>https://uh-zz.github.io/posts/category/development/2020/08/agile-software-development/</link><pubDate>Fri, 05 Jun 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/development/2020/08/agile-software-development/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener">ロードマップ&lt;/a>に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p>
&lt;h2 id="アジャイル開発">アジャイル開発&lt;/h2>
&lt;p>「アジャイル開発」っていうとなんかカッコいいしモダンっぽいというイメージをおそらく持っている人もいるでしょう。(私を含めて)&lt;/p>
&lt;p>逆に「ウォーターフォール開発」はなんか古臭いし、どこぞの金融系ぷ r、、おっと誰か来たみたいなのでこの辺で。&lt;/p>
&lt;p>とまあ、もてはやされたアジャイル開発ですが、フタを開けてみれば「要件定義 → 設計 → 実装 → テスト」の全工程を１つの単位として反復するという手法なのです。&lt;/p>
&lt;p>反復する期間はチームやプロジェクトによってまちまちですが、1 週間〜4 週間ほどです。&lt;/p>
&lt;p>ってことはですよ、V 字モデルのウォーターフォールを短いスパンで回してるだけ？、、それウォーターフォールじゃねぇか！！&lt;/p>
&lt;p>、、というヤジも分からなくはありませんが、ちゃんとメリットがあります。&lt;/p>
&lt;h2 id="メリット">メリット&lt;/h2>
&lt;h3 id="1-スピーディー早い">1. スピーディー(早い)&lt;/h3>
&lt;p>だってそうですよね。ウォーターフォールでは全工程を段階的に進めていくのでリリースまでに時間がかかってしまいます。&lt;/p>
&lt;p>対してアジャイルでは前工程を１つのサイクルとして反復するのでリリースまでの期間が短く済みます。&lt;/p>
&lt;h3 id="2-やすい安い-">2. やすい(安い ×)&lt;/h3>
&lt;p>しかもアジャイルは、開発サイクルが短い分、仕様変更や追加機能の対応がし&lt;strong>やすい&lt;/strong>というのもあります。&lt;/p>
&lt;p>ウォーターフォールだと、段階的に進めるので、１つの仕様変更があった場合、工程を戻すことになり、、おぉ、、考えただけでも恐ろしいですね。&lt;/p>
&lt;h3 id="3-ユーザーファーストうまい">3. ユーザーファースト(うまい?)&lt;/h3>
&lt;p>これも納得ですね。&lt;/p>
&lt;p>リリースが早い分、クライアント(ユーザー)に効率よく素早く提供できる → クライアント喜ぶ → 褒められる → 嬉しい=うまい?&lt;/p>
&lt;p>(これは数合わせです)&lt;/p>
&lt;h2 id="アジャイル開発の手法">アジャイル開発の手法&lt;/h2>
&lt;p>手法は以下の３つです。&lt;/p>
&lt;ul>
&lt;li>スクラム&lt;/li>
&lt;li>エクストリームプログラミング&lt;/li>
&lt;li>ユーザ機能駆動開発&lt;/li>
&lt;/ul>
&lt;p>この中で私が経験したのは、スクラムのみです。(2020/07 時点)&lt;/p>
&lt;p>どのサイトでも言われている通り、この開発手法ではメンバーとのコミュニケーションが&lt;strong>非常に&lt;/strong>重要です。&lt;/p>
&lt;p>そのイテレーション(スプリント)でリリースする機能も複数人が関わっていたり、メンバー間での連携が必要な機能だったり。。&lt;/p>
&lt;p>極めつけは１つのアプリの全機能を全メンバーが把握しているのがヨシとされるので、知らない機能は教えたり教わったりしないといけないからです。(これは私のチームだけなのかは知りませんが)&lt;/p>
&lt;h2 id="まとめ">まとめ&lt;/h2>
&lt;p>、、とすごく大変そうに見えますが(実際に大変ですが)、スクラムならではの団体戦みのある開発でまあうまく回せるんではないでしょうかというのが感想です。&lt;/p>
&lt;h2 id="備考">備考&lt;/h2>
&lt;p>表紙イラスト：&lt;a href="https://loosedrawing.com/" target="_blank" rel="noopener">Loose Drawing&lt;/a>&lt;/p></description></item></channel></rss>