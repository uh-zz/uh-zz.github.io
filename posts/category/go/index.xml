<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on small land</title><link>https://uh-zz.github.io/posts/category/go/</link><description>Recent content in Go on small land</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 05 May 2022 18:52:33 +0900</lastBuildDate><atom:link href="https://uh-zz.github.io/posts/category/go/index.xml" rel="self" type="application/rss+xml"/><item><title>球面三角法による２点間の距離計算をGoで実装してみた</title><link>https://uh-zz.github.io/posts/category/go/2020/07/spherical-trigonometry/</link><pubDate>Mon, 06 Jul 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/go/2020/07/spherical-trigonometry/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;p&gt;地球上の２点間の距離計算ってアプリだと Google Map API を使えば完了！だと思いますが、どう計算してるかって気になりますよね？&lt;/p&gt;
&lt;p&gt;今回は球面三角法を利用した地球上の２点間の距離計算を Go で実装します。（調べたらフツーにあるんですが）&lt;/p&gt;
&lt;h2 id="球面三角法とは"&gt;球面三角法とは&lt;/h2&gt;
&lt;p&gt;その名の通り、三角関数を利用して球面上の辺や角の大きさを導出するものです。平面と球面とでの違いは辺の大きさが
球面では中心角によって表されることにあります。&lt;/p&gt;
&lt;p&gt;よって、球面三角法を使用して算出した弧の長さ(中心角)と赤道の半径を乗算すると距離が求まります。&lt;/p&gt;
&lt;p&gt;球面三角法の証明については、&lt;a href="http://horibe.jp/PDFBOX/SphericalTriangles.pdf" target="_blank" rel="noopener"&gt;球面三角形の定理&lt;/a&gt;を参考にしました！&lt;/p&gt;
&lt;p&gt;(&amp;ldquo;高校生に向けて&amp;quot;とある通り、非常にわかりやすかったです)&lt;/p&gt;
&lt;p&gt;球面三角法の余弦定理を利用して実際に距離を算出する方法は&lt;a href="https://qiita.com/port-development/items/eea3a0a225be47db0fd4#%E7%90%83%E9%9D%A2%E4%B8%89%E8%A7%92%E6%B3%95%E3%81%AE%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86" target="_blank" rel="noopener"&gt;球面三角法の余弦定理&lt;/a&gt;がわかりやすいです。&lt;/p&gt;
&lt;h2 id="実装"&gt;実装&lt;/h2&gt;
&lt;p&gt;実装したソースコードは Github でも確認できます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/uh-zz/traning/tree/master/algorithm/distance" target="_blank" rel="noopener"&gt;球面三角法を利用した２点間の距離計算&lt;/a&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package main
import &amp;#34;math&amp;#34;
// Coordinate 緯度経度
type Coordinate struct {
Longitude float64
Latitude float64
}
// EarthRadius 赤道半径
const EarthRadius = 6378140
// DistanceOnTheEarth 地球上の 2 点間の距離を出す（球面三角法）
func DistanceOnTheEarth(from, to Coordinate) float64 {
fromLadLon := from.Longitude * math.Pi / 180
fromLadLat := from.Latitude * math.Pi / 180
toLadLon := to.Longitude * math.Pi / 180
toLadLat := to.Latitude * math.Pi / 180
alpha := math.Sin(fromLadLat)*math.Sin(toLadLat) +
math.Cos(fromLadLat)*math.Cos(toLadLat)*math.Cos(fromLadLon-toLadLon)
arcAlpha := math.Acos(alpha)
return arcAlpha * EarthRadius / 1000
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="動かしてみる"&gt;動かしてみる&lt;/h2&gt;
&lt;p&gt;それでは実装した Go の関数を呼び出す簡単なアプリを動かしていきます。&lt;/p&gt;</description></item><item><title>ソートアルゴリズムをGoで実装してみた</title><link>https://uh-zz.github.io/posts/category/go/2020/07/compare-sort-aligorithm/</link><pubDate>Sun, 05 Jul 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/go/2020/07/compare-sort-aligorithm/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;h2 id="マージソート"&gt;マージソート&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;マージソートは、ソートのアルゴリズムで、既に整列してある複数個の列を 1 個の列にマージする際に、小さいものから先に新しい列に並べれば、新しい列も整列されている、というボトムアップの分割統治法による。大きい列を多数の列に分割し、そのそれぞれをマージする作業は並列化できる。&lt;/p&gt;
&lt;p&gt;出典：&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88#:~:text=%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AF%E3%80%81%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AE,%E4%BD%9C%E6%A5%AD%E3%81%AF%E4%B8%A6%E5%88%97%E5%8C%96%E3%81%A7%E3%81%8D%E3%82%8B%E3%80%82" target="_blank" rel="noopener"&gt;wikipedia「マージソート」より引用&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;最悪の計算量が O(n log n) であるから少なくとも O(n^2)よりは速いんだろうなという印象（雑すぎるか）&lt;/p&gt;
&lt;p&gt;以下「&lt;a href="https://qiita.com/drken/items/44c60118ab3703f7727f" target="_blank" rel="noopener"&gt;ソートを極める！ 〜 なぜソートを学ぶのか 〜&lt;/a&gt;」を元に実装してみた（なるべくソースを見ないで実装を試みたがマージする箇所は折れた、、）&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package main
import (
&amp;#34;fmt&amp;#34;
&amp;#34;time&amp;#34;
&amp;#34;github.com/uh-zz/traning/algorithm/shuffle&amp;#34;
)
func main() {
// ランダムな要素 n 個のスライス取得
input := shuffle.RandomIntList(n)
inputLength := len(input)
// マージソート
MergeSort(&amp;amp;input, 0, inputLength)
}
// MergeSort マージソート
func MergeSort(input \*[]int, left, right int) {
// 要素数1つの場合は抜ける
if right-left == 1 {
return
}
// 配列を２つに分けるインデックス
middle := left + (right-left)/2
// 配列左側
MergeSort(input, left, middle)
// 配列右側
MergeSort(input, middle, right)
var buffer []int
// 左側と右側をバッファにためる（右側反転）
for index := left; index &amp;lt; middle; index++ {
buffer = append(buffer, (*input)[index])
}
for index := right - 1; index &amp;gt;= middle; index-- {
buffer = append(buffer, (*input)[index])
}
// マージする
scopeLeft := 0
scopeRight := len(buffer) - 1
for index := left; index &amp;lt; right; index++ {
if buffer[scopeLeft] &amp;lt;= buffer[scopeRight] {
// 左側採用
(*input)[index] = buffer[scopeLeft]
scopeLeft++
} else {
// 右側採用
(*input)[index] = buffer[scopeRight]
scopeRight--
}
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これ考えたのぶっ飛んでるなあと思って Wikipedia 見てたら、考案者が&lt;a href="https://ja.wikipedia.org/wiki/%E3%82%B8%E3%83%A7%E3%83%B3%E3%83%BB%E3%83%95%E3%82%A9%E3%83%B3%E3%83%BB%E3%83%8E%E3%82%A4%E3%83%9E%E3%83%B3" target="_blank" rel="noopener"&gt;フォン・ノイマン&lt;/a&gt;でやっぱりぶっ飛んでた（凄すぎ）&lt;/p&gt;</description></item></channel></rss>