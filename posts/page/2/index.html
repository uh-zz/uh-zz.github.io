<!doctype html><html lang=en><head><title>Posts</title><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.42f0921c87ff4ad9209795903c282a435df23b9b905e28b882168dd2486edcb6.css integrity="sha256-QvCSHIf/Stkgl5WQPCgqQ13yO5uQXii4ghaN0khu3LY="><link rel=icon type=image/png href=/images/bio_hu_1d7d85374227a333.jpg><link rel=alternate type=application/rss+xml href=https://uh-zz.github.io/posts/index.xml title="small land"><meta property="og:title" content="small land"><meta property="og:type" content="website"><meta property="og:description" content="技術とポエムを垂れ流しています"><meta property="og:image" content="/images/bio_1.jpg"><meta property="og:url" content="https://uh-zz.github.io/"><script data-goatcounter=https://uh-zz.goatcounter.com/count async src=//gc.zgo.at/count.js></script><script integrity="sha256-DO4ugzEwhTW1Id1UIWn0gUJWaebCYOypeTit6LW4QB4=">let theme=localStorage.getItem("theme-scheme")||localStorage.getItem("darkmode:color-scheme")||"light";theme==="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-posts kind-section" data-bs-spy=scroll data-bs-target=#TableOfContents data-bs-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/bio_hu_1d7d85374227a333.jpg id=logo alt=Logo>
small land</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ms-auto"><li class=nav-item><a class=nav-link href=/#home>Home</a></li><li class=nav-item><a class=nav-link href=/#about>About</a></li><li class=nav-item><a class=nav-link href=/#skills>Skills</a></li><li class=nav-item><a class=nav-link href=/#experiences>Experiences</a></li><li class=nav-item><a class=nav-link href=/#education>Education</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>More</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/#projects>Projects</a>
<a class=dropdown-item href=/#recent-posts>Recent Posts</a></div></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>Posts</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>Notes</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme"></a><div id=themeMenu class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# data-scheme=light><img class=theme-icon src=/icons/sun-svgrepo-com.svg width=20 alt="Light Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=dark><img class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=system><img class=theme-icon src=/icons/computer-svgrepo-com.svg width=20 alt="System Theme"></a></div></li></ul></div></div><img src=/images/bio_hu_1d7d85374227a333.jpg class=d-none id=main-logo alt=Logo>
<img src=/images/bio_hu_1d7d85374227a333.jpg class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><a class=list-link href=/posts/introduction/ title=Introduction>Introduction</a></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/> Category</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/aws/> AWS</a><ul><li><a class=list-link href=/posts/category/aws/2020/06/dynamo-only-sortkey-without-partionkey/ title="DynamoDB のソートキーだけで絞り込みたいとき">DynamoDB のソートキーだけで絞り込みたいとき</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/computer-science/> Computer Science</a><ul><li><a class=list-link href=/posts/category/computer-science/2020/11/thread-and-concurrency/ title=スレッドと並行処理>スレッドと並行処理</a></li><li><a class=list-link href=/posts/category/computer-science/2020/09/process-management/ title=プロセス管理>プロセス管理</a></li><li><a class=list-link href=/posts/category/computer-science/2020/10/memory-management/ title=メモリ管理>メモリ管理</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/development/> Development</a><ul><li><a class=list-link href=/posts/category/development/2020/08/agile-software-development/ title=アジャイル開発>アジャイル開発</a></li><li><a class=list-link href=/posts/category/development/2021/03/pragmatic-programmer/ title=達人プログラマーとは>達人プログラマーとは</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/go/> Go</a><ul><li><a class=list-link href=/posts/category/go/2022/12/qiita-advent-calender/ title=Futureパターンが使われているOSSを見てみた>Futureパターンが使われているOSSを見てみた</a></li><li><a class=list-link href=/posts/category/go/2022/12/kyash-advent-calendar/ title=kyash-advent-calendar>kyash-advent-calendar</a></li><li><a class=list-link href=/posts/category/go/2020/07/compare-sort-aligorithm/ title=ソートアルゴリズム>ソートアルゴリズム</a></li><li><a class=list-link href=/posts/category/go/2020/07/spherical-trigonometry/ title=球面三角法による２点間の距離計算>球面三角法による２点間の距離計算</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/inputs/> Inputs</a><ul><li><a class=list-link href=/posts/category/inputs/2022/07/ title=2022/07>2022/07</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/oss/> OSS</a><ul><li><a class=list-link href=/posts/category/oss/2020/08/semantic-versioning/ title="Semantic Versioning">Semantic Versioning</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/security/> Security</a><ul><li><a class=list-link href=/posts/category/security/2021/01/oauth/ title="OAuth について">OAuth について</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/system-design/> System Design</a><ul><li><a class=list-link href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/ title=システム設計-part1->システム設計-part1-</a></li><li><a class=list-link href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/ title=システム設計-part2->システム設計-part2-</a></li><li><a class=list-link href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/ title=システム設計-part3->システム設計-part3-</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/category/look-back-on/> 振り返り</a><ul><li><a class=list-link href=/posts/category/look-back-on/2021/ title=2021年の振り返り>2021年の振り返り</a></li><li><a class=list-link href=/posts/category/look-back-on/2022/05/31/go-to-the-teikyo-university/ title=【通信教育課程】帝京大学理工学部情報科学科に編入学しました>【通信教育課程】帝京大学理工学部情報科学科に編入学しました</a></li><li><a class=list-link href=/posts/category/look-back-on/2022/09/04/preview-courses-at-teikyo-univ/ title=履修科目一覧をNotionでつくりました>履修科目一覧をNotionでつくりました</a></li><li><a class=list-link href=/posts/category/look-back-on/2022/12/31/ title=2022年の振り返り>2022年の振り返り</a></li><li><a class=list-link href=/posts/category/look-back-on/2023/12/24/ title=2023年の振り返り>2023年の振り返り</a></li><li><a class=list-link href=/posts/category/look-back-on/2024/12/31/ title=2024年の振り返り>2024年の振り返り</a></li><li><a class=list-link href=/posts/category/look-back-on/2024/06/08/ title="Go Conference 2024に参加レポ">Go Conference 2024に参加レポ</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid post-card-holder" id=post-card-holder><div class=post-card><div class=card><div class=card-head><a href=/posts/category/security/2021/01/oauth/ class=post-card-link><img class=card-img-top src=/posts/category/security/2021/01/oauth/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/security/2021/01/oauth/ class=post-card-link><h5 class=card-title>OAuth について</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
OAuth とは ひとまず、一番分かりやすい OAuth の説明で大体の感覚がつかめますのでオススメです。
こちらでもざっくり説明させてもらうと、OAuth は複数のアプリを連携させるための仕組みです。
例えば、ブログの記事を更新した瞬間に、ブログから更新情報をツイートしたかったりする場合に使われます。
ただ、そのままツイートできるわけではなくて、ブログアプリがツイートする許可(認可)をしてあげる必要があります。
そして許可されたアプリは許可証(アクセストークン)を持っていることで、Twitter を使ってツイートできるという仕組みです。
メリット OAuth を使うことで、上の例であげたブログアプリは、Twitter のユーザ名とパスワードを知らなくてもツイートできるという点です。
巷のアプリはこれを使うことで、Google アカウントや Twitter など SNS アカウントを持っているだけでユーザ登録できちゃいます。最初の煩わしい登録の手間が省けて良いです。
OAuth1.0 OAuth の初期バージョンです。他に 1.0a という名前のバージョンもありますが、Twitter では 1.0a を使うことができるみたいです。 (後述の 2.0 も同様に使用可)
特徴としては、認証と署名を用いて実現される仕様でありますが、実装が複雑で使用する言語が限られてしまうというデメリット?があるみたいです。(堅牢ではあると思いますが)
また、1.0 は Web アプリのみ対応しているので、デスクトップ/モバイルアプリは蚊帳の外とこれまた制限されるみたいです。
(Twitter は Web アプリ以外でも使える xAuth という OAuth 拡張を開発したりしてたみたいです)
さらに悲しいことに、1.0 の仕様は次の 2.0 の策定を持って廃止されたみたいです。
OAuth2.0 後継です。複雑と言われていた署名(とトークン交換)をバッサリ省いています。
これによって実装しやすいものになりましたがセキュリティが気になるところです。
OAuth 1.0 のほうが OAuth 2.0 より安全なの？でも言われている通り、2.0 はクライアントアプリケーションの幅が広がった分、秘密鍵の隠蔽が難しくなるみたいです。。
隠蔽できるかの違いはありますが、セキュリティレベルは両者それほど変わらないみたいです。
(2.0 は経路を TLS 化していることで、1.0 よりも提示するパラメータが少なくなっているという事実はあるそうな)
まとめ 実装のことを考えてこれからも 2.0 を使っていきましょうという締めです。</p></a></div><div class=card-footer><span class=float-start>Tuesday, January 5, 2021
</span><a href=/posts/category/security/2021/01/oauth/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/ class=post-card-link><img class=card-img-top src=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/ class=post-card-link><h5 class=card-title>システム設計-part1-</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
設計パターン 値オブジェクト(Value Object) Java で変数を扱うとき、int や String などで型定義しがちな初心者丸出しの実装をしていた私ですが、値オブジェクトを知ったとき眼からウロコでした。
値オブジェクトとは、汎用的な型(int や String)で型を定義するのではなく、専用の型(クラスやインターフェース)を定義します。
範囲の広い汎用的な型を使うのではなく、業務に合わせた値で制限するというものです。
値オブジェクトクラスはこんなかんじ
class Quantity { static final int MIN = 1; static final int MAX = 100; int value; Quantity(int value) { if (value &lt; MIN) { throw new IllegalArgumentException("不正" + MIN + "未満"); } if (value > MAX) { throw new IllegalArgumentException("不正" + MAX + "超"); } this.value = value; } } そして参照はこんなかんじ
Quantity quantity = new Quantity(50); こうすることで Quantity 型は値の制限(0~100)付きの実装ができるので安全です。</p></a></div><div class=card-footer><span class=float-start>Saturday, December 5, 2020
</span><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/ class=post-card-link><img class=card-img-top src=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/ class=post-card-link><h5 class=card-title>システム設計-part2-</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
設計パターン 早期リターン 複雑になりがちな場合分けのロジックの見通しをよくしようというものです。
ありがちなif-elseをつなげた(例 1)
Yen fee() { Yen result; if (isChild()) { result = chidFee(); } else if (isSenior()) { result = seniorFee(); } else { result = adultFee(); } return result; } さっきのコードからローカル変数を抜いて結果をすぐにreturnするようにした(例 2)
Yen fee() { if (isChild()) { return chidFee(); } else if (isSenior()) { return seniorFee(); } else { return adultFee(); } } このように、値が決まるとすぐにreturnするやり方を早期リターンと言います。
ガード節 上記の例 2 からelseを抜いた(例 3)
Yen fee() { if (isChild()) return chidFee(); if (isSenior()) return seniorFee(); return adultFee(); } elseを抜いた早期リターンをガード節と言います。非常にコンパクトですね。</p></a></div><div class=card-footer><span class=float-start>Saturday, December 5, 2020
</span><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/ class=post-card-link><img class=card-img-top src=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/ class=post-card-link><h5 class=card-title>システム設計-part3-</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
業務ロジック メソッドをロジックの置き場所にする 現場で役立つシステム設計の原則では、&ldquo;従来"という表現をされていますが、手続き型と呼ばれている設計ではデータクラスと機能クラスに分けて表現します。
その名の通りデータクラスはデータを格納して、機能クラスはデータクラスのデータを判断、加工、計算するといった使い方です。
この手続き型の問題は、拡張するときの変更箇所の特定に時間がかかるということです。
なぜかというと、データクラスが参照できるクラスであれば、アーキテクチャのどのレイヤーにでもロジックが書けてしまうからです。
便利のようには見えますが、先に言った変更箇所の特定に時間がかかるこの方法は最善ではありません。
解決としては、Java 本来のクラスの使い方を踏襲することです。
データとロジックを 1 つのクラスに閉じてしまおうという考え方です。
class PersonName { private String firstName; private String lastName; String fullName() { return String.format("%s %s", firstName, lastName); } } データであるfirstNameとlastName、そしてロジック(メソッド)のfullName()が同じクラス内にあります。
こうするとクラス内でデータを扱うことができて変更もこのクラス内で閉じることができます。
また、メソッドはクラス内のインスタンス変数(firstNameやlastName)を使って何らかの処理を行う用途で作成します。
クラスが肥大化したら小さく分ける これもやってしまいがちですが、改修を繰り返していくうちに、クラスが大きくなっていきます。
大きくなったクラスは手続き型同様に変更箇所の特定に時間がかかります。
それを防ぐために、大きくなってしまったクラスを次のルールで細分化します。
インスタンス変数とメソッドを対応付ける メソッドが全てのインスタンス変数を使うようになる 細分化したクラスはそれぞれ独立性が高くなるので、別のクラスで使う時にも再利用ができるようになります。
こうした関連の強いデータとロジックをまとめたクラスを凝集度が高いと言います。
凝集度が高いクラスは、変更箇所もそのクラスに閉じることになるので、疎結合になり他への影響が少なくて済みます。
まとめ 時すでに遅しと言いますか、現場での反省点をつらつら振り返ってベストプラクティスを学んでいるという感じです。
次回に活かそうというモチベーションは上がるのでいい復習方法だと感じます。
備考 現場で役立つシステム設計の原則
表紙イラスト：Loose Drawing</p></a></div><div class=card-footer><span class=float-start>Saturday, December 5, 2020
</span><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/computer-science/2020/11/thread-and-concurrency/ class=post-card-link><img class=card-img-top src=/posts/category/computer-science/2020/11/thread-and-concurrency/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/computer-science/2020/11/thread-and-concurrency/ class=post-card-link><h5 class=card-title>スレッドと並行処理</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
スレッド プロセスが最低１つは持っている実行単位のことです。
こんな言い方をするのは、プロセスが複数のスレッドを管理できるからです。
実行単位という視点でプロセスとの違いは、「アドレス空間」を共有できるという点です。
尾を引くようにプロセス管理の話に繋がりますが、プロセスにはそれぞれ１つのアドレス空間が割り当てられます。
そして別のプロセスからアドレス空間へのアクセスは原則できません。(これを可能にするために共有メモリという方法を使います)
それに対して、スレッドは１つのプロセスの実行単位を分けたものですから、同じアドレス空間を共有できるというわけです。
そういうわけで、スレッドとプロセスをそれぞれ複数起動する場合は、スレッドの方がアドレス空間を１つで済ませることができるため省コストになります。
では、複数のスレッドを起動してやることは?というと並行処理です。
並行処理 これもすでに出てきている話ではあります。プロセス管理の記事で出した複数アプリを同時に起動させるという部分です。
「同時に」というのは私たちユーザがそう解釈しているだけで、アプリはカーネルが割り当てた非常に短い処理時間ごとに切り替えているのでしたよね。これが並行処理です。
スレッドでも同じように短い処理時間ごとに切り替えて「同時に」処理させることができます。
並列処理との違い 私自身、再三調べては納得 → 忘れるを繰り返していましたが、プロセス管理(3 度目)をまとめることでやっと理解できたと思います。
並行処理では処理時間ごとに切り替えると言いましたが、並列処理では CPU １つは言わず２つで処理してしまえばいいじゃないという考え方です。
図で見ると非常にわかりやすいのですが、並行処理だとパン食べてチーズ食べてハム食べてレタス食べて、、を繰り返して食べ切る作戦なのに対して、並列処理はミックスサンドとして食べ切るようなイメージです。
そんなの絶対ミックスサンドとして処理したら無限じゃんと思われますが、並列処理にも上限があるようです。
アムダールの法則といって複数のプロセッサ(CPU のことですね)を使って並列化による高速化を行う場合、そのプログラムの中で逐次的に実行される処理部分(並列)の時間によって、高速化が制限されるというものです。
出典：wikipedia「アムダールの法則」より引用
まあ、上限があるといっても高速するのに変わりはないわけです。
今回はその中でも比較的面白い実装を見つけたのでそれを紹介します。
ワーカープール スレッドプールとも呼ばれるものです。並行処理でたくさんのスレッドを起動して、、というのももちろん可能ですが、それには代償が伴います。
ワーカープールはそのようにいくつもスレッドを起動させるのではなく、すでに起動したスレッドを使い回そうの精神で実装される並行処理です。
以下のような実装です。
こちらを参考にさせていただきました。
(ほぼコメントつけただけですが)
package main import ( "fmt" "time" ) // 使い回し用のワーカー func worker(id int, jobs &lt;-chan int, results chan&lt;- int) { for j := range jobs { fmt.Println("worker", id, "started job", j) time.Sleep(time.Second) // 1秒待ち(重い処理を想定) fmt.Println("worker", id, "finished job", j) results &lt;- j * 2 } } func main() { // タスクの数 const numJobs = 5 // こなさなければいけないタスク jobs := make(chan int, numJobs) // タスクの成果物 results := make(chan int, numJobs) for w := 1; w &lt;= 3; w++ { // 使い回し用のワーカーだけ生成しておく(この状態ではまだタスクをもらってないのでブロック) go worker(w, jobs, results) } // タスク数だけjobsに渡す for j := 1; j &lt;= numJobs; j++ { // チャネルへの書き込みを契機にワーカー起動 jobs &lt;- j } // タスク数だけ格納されたらチャネルを閉じる close(jobs) for a := 1; a &lt;= numJobs; a++ { &lt;-results } } // 結果 worker 3 started job 1 worker 1 started job 2 worker 2 started job 3 worker 3 finished job 1 worker 3 started job 4 worker 1 finished job 2 worker 1 started job 5 worker 2 finished job 3 worker 1 finished job 5 worker 3 finished job 4 実行するとわかりますが、順番がごっちゃになって処理されているのがわかります。</p></a></div><div class=card-footer><span class=float-start>Monday, October 5, 2020
</span><a href=/posts/category/computer-science/2020/11/thread-and-concurrency/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/computer-science/2020/10/memory-management/ class=post-card-link><img class=card-img-top src=/posts/category/computer-science/2020/10/memory-management/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/computer-science/2020/10/memory-management/ class=post-card-link><h5 class=card-title>メモリ管理</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
仮想メモリ プロセス管理でもあったように、メモリはアドレス空間ごとにプロセスを管理します。
アドレス空間は 4KB/8KB 単位のページに分割して管理されています。
ページはそれぞれ論理アドレス、物理アドレスを対応づける単位でもあります。
論理アドレスと物理アドレスは常に紐づけられているわけではなく、そのページが必要になった時点で割り当てることも可能です。
そのため、論理アドレスを実際の物理アドレスの容量より大きく確保することができます。
(実際に使えるメモリの量よりも大きなメモリを想定できるということです。)
仮装メモリとして使う仕組みには次の３つが挙げられます。
ページング 仮想メモリといえばこれ、という風に教えられるものの筆頭かと思います。
ハードディスクを物理メモリの代わりに使うといったものです。
物理メモリが不足すると、OS のコアであるカーネルは使われていないページをハードディスクに移して論理アドレスを解放します。
そしてプロセスがハードディスクに移されたページにアクセスしようとすると、カーネルがプロセスを停止し、ハードディスクのページを再度物理メモリに読み込み、論理アドレスを対応づけます。
また、プロセス全体を単位にする場合はスワッピングと呼ばれます。
メモリマップトファイル ファイルをメモリとしてアクセスすることができるものです。
アクセスがあった瞬間に、カーネルがファイルをメモリに読み込みます。プロセスがメモリを使い終わると、論理アドレスと物理アドレスを解放して、メモリの内容をファイルに保存します。
共有メモリ １つの物理アドレスを、複数のプロセスの論理アドレスに対応づけるものです。 アドレス空間をまたぐと危険では？！という見方もありますが、複数プロセスで処理できるため、巨大な画像データを編集するときには都合が良いみたいです。
※Go では共有メモリを使わずに Message Passing を使っています。
メモリ管理 API malloc(3) メモリをヒープ領域に割り当てます。プログラム実行時に決まるサイズのメモリはヒープ領域から確保します。
ヒープは「何かを積み重ねた山」のことで、その名の通り、プログラムを実行してから決定する量だけメモリを確保しておく領域なので納得です。
malloc で確保したメモリはfreeで解放しなければいけません。
calloc(3) メモリをヒープ領域に割り当てます。malloc と異なる点は、割り当てたメモリをゼロクリアすることです。
こちらも malloc 同様、確保したメモリはfreeで解放しなければいけません。
realloc(3) malloc で割り当てたメモリのサイズを拡大、縮小します。こちらも確保したメモリはfreeで解放しなければいけません。
free 割り当てたメモリを開放します。いったん開放したアドレスにはアクセスしてはいけません。
メモリの開放漏れを防ぐために、malloc で確保したメモリは常に free で開放されるべきです。
brk(2) malloc や realloc が割り当てるためのメモリを探してくるものです。
物理アドレスが割り当てられていないページに物理アドレスを対応づけます。
余談 メモリはエラーでもかなりお世話になる部分なので、次回以降、実際のエラーやプログラミング言語(Go か Java)に絡めた記事を書きたいです。
備考 ふつうの Linux プログラミング 第 2 版 Linux の仕組みから学べる gcc プログラミングの王道</p></a></div><div class=card-footer><span class=float-start>Monday, October 5, 2020
</span><a href=/posts/category/computer-science/2020/10/memory-management/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/oss/2020/08/semantic-versioning/ class=post-card-link><img class=card-img-top src=/posts/category/oss/2020/08/semantic-versioning/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/oss/2020/08/semantic-versioning/ class=post-card-link><h5 class=card-title>Semantic Versioning</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
セマンティックバージョニング？ アプリに振るバージョン番号をSemVerというルールに従って付与しましょうというものです。
確かにバージョン番号に意味を持たせることで、ユーザからもアプリのバージョン番号が上がればバグ修正なのか機能追加なのかわかりますし、プログラムからも互換性を考慮して処理を分けることができるのでよいですね。
これだけ覚えておけば OK バージョン番号の形式は、メジャー.マイナー.パッチです。(例：1.0.0)
メジャー 後方互換性がない変更があった時にはこの番号を上げなければいけません(MUST) この番号を上げた際には、マイナー/パッチの番号は 0 にリセットしなければいけません(MUST) この番号が「0」の場合は初期開発用として扱います。リリースの段階でこの番号を「1」に上げます。 マイナー 後方互換性を保ちつつ、機能追加のある時にはこの番号を上げなければいけません(MUST) この番号を上げた際には、パッチの番号は 0 にリセットしなければいけません(MUST) パッチ 後方互換性を保ちつつ、バグ修正のある時にはこの番号を上げなければいけません(MUST) ※バグ修正とは間違った振る舞いを修正する内部の変更のことをいいます。
ちょっと踏み込むと プレリリースバージョンには、パッチ番号の後ろにハイフンで区切って識別子をつけることができます。 (例：1.1.0-alpha / 1.1.0-beta / 1.1.0-rc) ※ちなみに識別子のrcは「release candidate」の略でベータ版よりもさらに製品版に近い品質のバージョンにつけるそうです。（略を初めて知りました。）
あと npm の packagge.json でもモジュールをセマンティックバージョンで管理してます。（~や^が付与されているのをよく見ると思います。） これについては上、真ん中、下で覚えるバージョニング範囲指定がわかりやすかったので共有しておきます。
余談 たかがバージョニング、されどバージョニングといった感じでした。知ってて損はないですよね。
備考 表紙イラスト：Loose Drawing</p></a></div><div class=card-footer><span class=float-start>Wednesday, August 5, 2020
</span><a href=/posts/category/oss/2020/08/semantic-versioning/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/go/2020/07/spherical-trigonometry/ class=post-card-link><img class=card-img-top src=/posts/category/go/2020/07/spherical-trigonometry/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/go/2020/07/spherical-trigonometry/ class=post-card-link><h5 class=card-title>球面三角法による２点間の距離計算をGoで実装してみた</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
地球上の２点間の距離計算ってアプリだと Google Map API を使えば完了！だと思いますが、どう計算してるかって気になりますよね？
今回は球面三角法を利用した地球上の２点間の距離計算を Go で実装します。（調べたらフツーにあるんですが）
球面三角法とは その名の通り、三角関数を利用して球面上の辺や角の大きさを導出するものです。平面と球面とでの違いは辺の大きさが 球面では中心角によって表されることにあります。
よって、球面三角法を使用して算出した弧の長さ(中心角)と赤道の半径を乗算すると距離が求まります。
球面三角法の証明については、球面三角形の定理を参考にしました！
(&ldquo;高校生に向けて"とある通り、非常にわかりやすかったです)
球面三角法の余弦定理を利用して実際に距離を算出する方法は球面三角法の余弦定理がわかりやすいです。
実装 実装したソースコードは Github でも確認できます。
球面三角法を利用した２点間の距離計算
package main import "math" // Coordinate 緯度経度 type Coordinate struct { Longitude float64 Latitude float64 } // EarthRadius 赤道半径 const EarthRadius = 6378140 // DistanceOnTheEarth 地球上の 2 点間の距離を出す（球面三角法） func DistanceOnTheEarth(from, to Coordinate) float64 { fromLadLon := from.Longitude * math.Pi / 180 fromLadLat := from.Latitude * math.Pi / 180 toLadLon := to.Longitude * math.Pi / 180 toLadLat := to.Latitude * math.Pi / 180 alpha := math.Sin(fromLadLat)*math.Sin(toLadLat) + math.Cos(fromLadLat)*math.Cos(toLadLat)*math.Cos(fromLadLon-toLadLon) arcAlpha := math.Acos(alpha) return arcAlpha * EarthRadius / 1000 } 動かしてみる それでは実装した Go の関数を呼び出す簡単なアプリを動かしていきます。</p></a></div><div class=card-footer><span class=float-start>Monday, July 6, 2020
</span><a href=/posts/category/go/2020/07/spherical-trigonometry/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/go/2020/07/compare-sort-aligorithm/ class=post-card-link><img class=card-img-top src=/posts/category/go/2020/07/compare-sort-aligorithm/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/go/2020/07/compare-sort-aligorithm/ class=post-card-link><h5 class=card-title>ソートアルゴリズムをGoで実装してみた</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
マージソート マージソートは、ソートのアルゴリズムで、既に整列してある複数個の列を 1 個の列にマージする際に、小さいものから先に新しい列に並べれば、新しい列も整列されている、というボトムアップの分割統治法による。大きい列を多数の列に分割し、そのそれぞれをマージする作業は並列化できる。
出典：wikipedia「マージソート」より引用
最悪の計算量が O(n log n) であるから少なくとも O(n^2)よりは速いんだろうなという印象（雑すぎるか）
以下「ソートを極める！ 〜 なぜソートを学ぶのか 〜」を元に実装してみた（なるべくソースを見ないで実装を試みたがマージする箇所は折れた、、）
package main import ( "fmt" "time" "github.com/uh-zz/traning/algorithm/shuffle" ) func main() { // ランダムな要素 n 個のスライス取得 input := shuffle.RandomIntList(n) inputLength := len(input) // マージソート MergeSort(&amp;input, 0, inputLength) } // MergeSort マージソート func MergeSort(input \*[]int, left, right int) { // 要素数1つの場合は抜ける if right-left == 1 { return } // 配列を２つに分けるインデックス middle := left + (right-left)/2 // 配列左側 MergeSort(input, left, middle) // 配列右側 MergeSort(input, middle, right) var buffer []int // 左側と右側をバッファにためる（右側反転） for index := left; index &lt; middle; index++ { buffer = append(buffer, (*input)[index]) } for index := right - 1; index >= middle; index-- { buffer = append(buffer, (*input)[index]) } // マージする scopeLeft := 0 scopeRight := len(buffer) - 1 for index := left; index &lt; right; index++ { if buffer[scopeLeft] &lt;= buffer[scopeRight] { // 左側採用 (*input)[index] = buffer[scopeLeft] scopeLeft++ } else { // 右側採用 (*input)[index] = buffer[scopeRight] scopeRight-- } } } これ考えたのぶっ飛んでるなあと思って Wikipedia 見てたら、考案者がフォン・ノイマンでやっぱりぶっ飛んでた（凄すぎ）</p></a></div><div class=card-footer><span class=float-start>Sunday, July 5, 2020
</span><a href=/posts/category/go/2020/07/compare-sort-aligorithm/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/computer-science/2020/09/process-management/ class=post-card-link><img class=card-img-top src=/posts/category/computer-science/2020/09/process-management/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/computer-science/2020/09/process-management/ class=post-card-link><h5 class=card-title>プロセス管理</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
プロセスとは プロセスという概念は Linux において、ファイルシステム、ストリームに並んで重要な構成要素の１つです。
プログラマが作成したソースコードはファイルに保存されます。そしてファイルの保存先はハードディスクです。
プログラムの実行時、プログラムはハードディスクからメモリへと読み込まれます。
CPU はメモリに読み込まれたプログラムを順次処理していきます。このとき、メモリに読み込まれて CPU に処理されているプログラムをプロセスといいます。
１つのプロセスを処理できるのは１つの CPU のみです。
そのため、同じプロセスしか一度に実行できなくなるといったことを避けるために、CPU はプロセスごとに処理時間を決めて次々に切り替えます。
普段使っている PC やスマホは Youtube や Line や Twitter など、複数アプリを同時に起動して使用しています。
あれは CPU が処理時間を決めて順に処理しているために実現されています。
OS のコアであるカーネルはプロセスの優先順位を考慮して、各プロセスに処理時間を割り当てます。
(この機能をスケジューラ、またはディスパッチャといいます。)
アドレス空間 プロセス１つに対して、CPU とメモリがそれぞれ１つ必要です。CPU は前述の通り、処理時間を割り当てるのに対し、メモリはプロセスごとにアドレス空間を割り当てます。
メモリにプログラムを書き込む際にはアドレスが必要です。
しかしプロセスには 0 番地から始まるメモリが必要なため、１つのプロセスしか使えなくなってしまいます。
そこでプロセスから見えるアドレス(論理アドレス)と実際のアドレス(物理アドレス)を分けてしまいます。
こうすることで、カーネルと CPU によって論理アドレス → 物理アドレスと変換された実際のアドレスに対して書き込むことができます。
１つのプロセスの論理アドレス、物理アドレスを全体としてアドレス空間といいます。
アドレス空間はプロセスごとに割り当てられるので他のプロセスにアクセスできなくなります。
プロセス API fork(2) 自分のプロセスを複製して新しいプロセスを作ります。
Github でも fork がありますが、意味合いは同じです。既存のリポジトリを複製します。複製したリポジトリは自由に更新できますが、fork した元のリポジトリに対しては更新はできません。
プロセスの fork は元からあるプロセスを親プロセス、複製されたプロセスを子プロセスと呼びます。
子プロセスの fork 実行時の戻り値は 0 です。
(戻り値 0 は正常終了のステータスコード)そして親プロセスの fork 実行時の戻り値は子プロセスのプロセス ID です。</p></a></div><div class=card-footer><span class=float-start>Sunday, July 5, 2020
</span><a href=/posts/category/computer-science/2020/09/process-management/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/aws/2020/06/dynamo-only-sortkey-without-partionkey/ class=post-card-link><img class=card-img-top src=/posts/category/aws/2020/06/dynamo-only-sortkey-without-partionkey/hero.svg alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/aws/2020/06/dynamo-only-sortkey-without-partionkey/ class=post-card-link><h5 class=card-title>DynamoDB のソートキーだけで絞り込みたいとき</h5><p class="card-text post-summary">はじめに Dynamo のテーブルに GSI(グローバルセカンダリインデックス)を貼ってハッシュキー＋ソートキーでクエリするパターンが通常の使い方かと思います。
ではソートキーを日付にしていた場合、同じ日付範囲のデータを一括で取得できる方法はありますでしょうか？
公式ドキュメントにはその辺の Tips なかったのですが、同僚から以下の記事を教えてもらいました。
DynamoDB の設計力をあげたい
これの設計２を参考にしました。
全データ共通のダミー列を用意して、以下の GSI を作成します。
パーティションキーはダミー列 ソートキーに日付 これで同じ日付範囲の複数データを引っ張ってくることが可能になります。
確かに美しいと言えないかもしれませんが、機転の効いた方法だと思いました。</p></a></div><div class=card-footer><span class=float-start>Friday, June 5, 2020
</span><a href=/posts/category/aws/2020/06/dynamo-only-sortkey-without-partionkey/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/posts/category/development/2020/08/agile-software-development/ class=post-card-link><img class=card-img-top src=/posts/category/development/2020/08/agile-software-development/hero.png alt="Hero Image"></a></div><div class=card-body><a href=/posts/category/development/2020/08/agile-software-development/ class=post-card-link><h5 class=card-title>アジャイル開発</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
アジャイル開発 「アジャイル開発」っていうとなんかカッコいいしモダンっぽいというイメージをおそらく持っている人もいるでしょう。(私を含めて)
逆に「ウォーターフォール開発」はなんか古臭いし、どこぞの金融系ぷ r、、おっと誰か来たみたいなのでこの辺で。
とまあ、もてはやされたアジャイル開発ですが、フタを開けてみれば「要件定義 → 設計 → 実装 → テスト」の全工程を１つの単位として反復するという手法なのです。
反復する期間はチームやプロジェクトによってまちまちですが、1 週間〜4 週間ほどです。
ってことはですよ、V 字モデルのウォーターフォールを短いスパンで回してるだけ？、、それウォーターフォールじゃねぇか！！
、、というヤジも分からなくはありませんが、ちゃんとメリットがあります。
メリット 1. スピーディー(早い) だってそうですよね。ウォーターフォールでは全工程を段階的に進めていくのでリリースまでに時間がかかってしまいます。
対してアジャイルでは前工程を１つのサイクルとして反復するのでリリースまでの期間が短く済みます。
2. やすい(安い ×) しかもアジャイルは、開発サイクルが短い分、仕様変更や追加機能の対応がしやすいというのもあります。
ウォーターフォールだと、段階的に進めるので、１つの仕様変更があった場合、工程を戻すことになり、、おぉ、、考えただけでも恐ろしいですね。
3. ユーザーファースト(うまい?) これも納得ですね。
リリースが早い分、クライアント(ユーザー)に効率よく素早く提供できる → クライアント喜ぶ → 褒められる → 嬉しい=うまい?
(これは数合わせです)
アジャイル開発の手法 手法は以下の３つです。
スクラム エクストリームプログラミング ユーザ機能駆動開発 この中で私が経験したのは、スクラムのみです。(2020/07 時点)
どのサイトでも言われている通り、この開発手法ではメンバーとのコミュニケーションが非常に重要です。
そのイテレーション(スプリント)でリリースする機能も複数人が関わっていたり、メンバー間での連携が必要な機能だったり。。
極めつけは１つのアプリの全機能を全メンバーが把握しているのがヨシとされるので、知らない機能は教えたり教わったりしないといけないからです。(これは私のチームだけなのかは知りませんが)
まとめ 、、とすごく大変そうに見えますが(実際に大変ですが)、スクラムならではの団体戦みのある開発でまあうまく回せるんではないでしょうかというのが感想です。
備考 表紙イラスト：Loose Drawing</p></a></div><div class=card-footer><span class=float-start>Friday, June 5, 2020
</span><a href=/posts/category/development/2020/08/agile-software-development/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div></div><div class=paginator><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label="Page 1" class=page-link role=button>1</a></li><li class="page-item active"><a aria-current=page aria-label="Page 2" class=page-link role=button>2</a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Next class=page-link role=button tabindex=-1><span aria-hidden=true>&#187;</span></a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Last class=page-link role=button tabindex=-1><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-start"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#about>About</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#skills>Skills</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#experiences>Experiences</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#education>Education</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#projects>Projects</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#recent-posts>Recent Posts</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><a href=mailto:uhzz.contact@gmail.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>uhzz.contact@gmail.com</span></a></li></ul></div></div></div><hr><div class=container><div class="row text-start"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu_b3360284c55cf72d.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">Copyright © 2024 uh-zz, All rights reserved.</div><div class="col-md-4 text-end"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.6f3796747df517956ba3216e8b6b10bcb9650389c17fbe6d1973ca917e75fd93.js integrity="sha256-bzeWdH31F5VroyFui2sQvLllA4nBf75tGXPKkX51/ZM=" defer></script></body></html>