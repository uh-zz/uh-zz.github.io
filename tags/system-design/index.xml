<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System-Design on puffer-fish</title><link>https://uh-zz.github.io/tags/system-design/</link><description>Recent content in System-Design on puffer-fish</description><generator>Hugo -- gohugo.io</generator><language>jp</language><lastBuildDate>Sat, 05 Dec 2020 18:07:06 +0900</lastBuildDate><atom:link href="https://uh-zz.github.io/tags/system-design/index.xml" rel="self" type="application/rss+xml"/><item><title>システム設計-part1-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;p&gt;※&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener"&gt;現場で役立つシステム設計の原則&lt;/a&gt;を元に記事を作成しています。&lt;/p&gt;
&lt;h2 id="設計パターン"&gt;設計パターン&lt;/h2&gt;
&lt;h3 id="値オブジェクトvalue-object"&gt;値オブジェクト(Value Object)&lt;/h3&gt;
&lt;p&gt;Java で変数を扱うとき、int や String などで型定義しがちな初心者丸出しの実装をしていた私ですが、値オブジェクトを知ったとき眼からウロコでした。&lt;/p&gt;
&lt;p&gt;値オブジェクトとは、汎用的な型(int や String)で型を定義するのではなく、&lt;strong&gt;専用の&lt;/strong&gt;型(クラスやインターフェース)を定義します。&lt;/p&gt;
&lt;p&gt;範囲の広い汎用的な型を使うのではなく、業務に合わせた値で制限するというものです。&lt;/p&gt;
&lt;p&gt;値オブジェクトクラスはこんなかんじ&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class Quantity {
static final int MIN = 1;
static final int MAX = 100;
int value;
Quantity(int value) {
if (value &amp;lt; MIN) {
throw new IllegalArgumentException(&amp;#34;不正&amp;#34; + MIN + &amp;#34;未満&amp;#34;);
}
if (value &amp;gt; MAX) {
throw new IllegalArgumentException(&amp;#34;不正&amp;#34; + MAX + &amp;#34;超&amp;#34;);
}
this.value = value;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そして参照はこんなかんじ&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Quantity quantity = new Quantity(50);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こうすることで Quantity 型は値の制限(0~100)付きの実装ができるので安全です。&lt;/p&gt;</description></item><item><title>システム設計-part2-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;p&gt;※&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener"&gt;現場で役立つシステム設計の原則&lt;/a&gt;を元に記事を作成しています。&lt;/p&gt;
&lt;h2 id="設計パターン"&gt;設計パターン&lt;/h2&gt;
&lt;h3 id="早期リターン"&gt;早期リターン&lt;/h3&gt;
&lt;p&gt;複雑になりがちな場合分けのロジックの見通しをよくしようというものです。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ありがちな&lt;code&gt;if-else&lt;/code&gt;をつなげた(例 1)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Yen fee() {
Yen result;
if (isChild()) {
result = chidFee();
} else if (isSenior()) {
result = seniorFee();
} else {
result = adultFee();
}
return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;さっきのコードからローカル変数を抜いて結果をすぐに&lt;code&gt;return&lt;/code&gt;するようにした(例 2)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Yen fee() {
if (isChild()) {
return chidFee();
} else if (isSenior()) {
return seniorFee();
} else {
return adultFee();
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このように、値が決まるとすぐに&lt;code&gt;return&lt;/code&gt;するやり方を&lt;strong&gt;早期リターン&lt;/strong&gt;と言います。&lt;/p&gt;
&lt;h3 id="ガード節"&gt;ガード節&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;上記の例 2 から&lt;code&gt;else&lt;/code&gt;を抜いた(例 3)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Yen fee() {
if (isChild()) return chidFee();
if (isSenior()) return seniorFee();
return adultFee();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;else&lt;/code&gt;を抜いた早期リターンを&lt;strong&gt;ガード節&lt;/strong&gt;と言います。非常にコンパクトですね。&lt;/p&gt;</description></item><item><title>システム設計-part3-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;p&gt;※&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener"&gt;現場で役立つシステム設計の原則&lt;/a&gt;を元に記事を作成しています。&lt;/p&gt;
&lt;h2 id="業務ロジック"&gt;業務ロジック&lt;/h2&gt;
&lt;h3 id="メソッドをロジックの置き場所にする"&gt;メソッドをロジックの置き場所にする&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener"&gt;現場で役立つシステム設計の原則&lt;/a&gt;では、&amp;ldquo;従来&amp;quot;という表現をされていますが、手続き型と呼ばれている設計ではデータクラスと機能クラスに分けて表現します。&lt;/p&gt;
&lt;p&gt;その名の通りデータクラスはデータを格納して、機能クラスはデータクラスのデータを判断、加工、計算するといった使い方です。&lt;/p&gt;
&lt;p&gt;この手続き型の問題は、拡張するときの変更箇所の特定に時間がかかるということです。&lt;/p&gt;
&lt;p&gt;なぜかというと、データクラスが参照できるクラスであれば、アーキテクチャのどのレイヤーにでもロジックが書けてしまうからです。&lt;/p&gt;
&lt;p&gt;便利のようには見えますが、先に言った変更箇所の特定に時間がかかるこの方法は最善ではありません。&lt;/p&gt;
&lt;p&gt;解決としては、Java 本来のクラスの使い方を踏襲することです。&lt;/p&gt;
&lt;p&gt;データとロジックを 1 つのクラスに閉じてしまおうという考え方です。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class PersonName {
private String firstName;
private String lastName;
String fullName() {
return String.format(&amp;#34;%s %s&amp;#34;, firstName, lastName);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;データである&lt;code&gt;firstName&lt;/code&gt;と&lt;code&gt;lastName&lt;/code&gt;、そしてロジック(メソッド)の&lt;code&gt;fullName()&lt;/code&gt;が同じクラス内にあります。&lt;/p&gt;
&lt;p&gt;こうするとクラス内でデータを扱うことができて変更もこのクラス内で閉じることができます。&lt;/p&gt;
&lt;p&gt;また、メソッドはクラス内のインスタンス変数(&lt;code&gt;firstName&lt;/code&gt;や&lt;code&gt;lastName&lt;/code&gt;)を使って何らかの処理を行う用途で作成します。&lt;/p&gt;
&lt;h3 id="クラスが肥大化したら小さく分ける"&gt;クラスが肥大化したら小さく分ける&lt;/h3&gt;
&lt;p&gt;これもやってしまいがちですが、改修を繰り返していくうちに、クラスが大きくなっていきます。&lt;/p&gt;
&lt;p&gt;大きくなったクラスは手続き型同様に変更箇所の特定に時間がかかります。&lt;/p&gt;
&lt;p&gt;それを防ぐために、大きくなってしまったクラスを次のルールで細分化します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;インスタンス変数とメソッドを対応付ける&lt;/li&gt;
&lt;li&gt;メソッドが全てのインスタンス変数を使うようになる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;細分化したクラスはそれぞれ独立性が高くなるので、別のクラスで使う時にも再利用ができるようになります。&lt;/p&gt;
&lt;p&gt;こうした関連の強いデータとロジックをまとめたクラスを&lt;strong&gt;凝集度が高い&lt;/strong&gt;と言います。&lt;/p&gt;
&lt;p&gt;凝集度が高いクラスは、変更箇所もそのクラスに閉じることになるので、疎結合になり他への影響が少なくて済みます。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;時すでに遅しと言いますか、現場での反省点をつらつら振り返ってベストプラクティスを学んでいるという感じです。&lt;/p&gt;
&lt;p&gt;次回に活かそうというモチベーションは上がるのでいい復習方法だと感じます。&lt;/p&gt;
&lt;h2 id="備考"&gt;備考&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X" target="_blank" rel="noopener"&gt;現場で役立つシステム設計の原則&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表紙イラスト：&lt;a href="https://loosedrawing.com/" target="_blank" rel="noopener"&gt;Loose Drawing&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>