<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer-Science on puffer-fish</title><link>https://uh-zz.github.io/tags/computer-science/</link><description>Recent content in Computer-Science on puffer-fish</description><generator>Hugo -- gohugo.io</generator><language>jp</language><lastBuildDate>Mon, 05 Oct 2020 18:07:06 +0900</lastBuildDate><atom:link href="https://uh-zz.github.io/tags/computer-science/index.xml" rel="self" type="application/rss+xml"/><item><title>スレッドと並行処理</title><link>https://uh-zz.github.io/posts/category/computer-science/2020/11/thread-and-concurrency/</link><pubDate>Mon, 05 Oct 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/computer-science/2020/11/thread-and-concurrency/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;h2 id="スレッド"&gt;スレッド&lt;/h2&gt;
&lt;p&gt;プロセスが最低１つは持っている実行単位のことです。&lt;/p&gt;
&lt;p&gt;こんな言い方をするのは、プロセスが複数のスレッドを管理できるからです。&lt;/p&gt;
&lt;p&gt;実行単位という視点でプロセスとの違いは、「アドレス空間」を共有できるという点です。&lt;/p&gt;
&lt;p&gt;尾を引くように&lt;a href="https://uh-zz.github.io/blog/posts/about-process/" target="_blank" rel="noopener"&gt;プロセス管理&lt;/a&gt;の話に繋がりますが、プロセスにはそれぞれ１つのアドレス空間が割り当てられます。&lt;/p&gt;
&lt;p&gt;そして別のプロセスからアドレス空間へのアクセスは原則できません。(これを可能にするために共有メモリという方法を使います)&lt;/p&gt;
&lt;p&gt;それに対して、スレッドは１つのプロセスの実行単位を分けたものですから、同じアドレス空間を共有できるというわけです。&lt;/p&gt;
&lt;p&gt;そういうわけで、スレッドとプロセスをそれぞれ複数起動する場合は、スレッドの方がアドレス空間を１つで済ませることができるため省コストになります。&lt;/p&gt;
&lt;p&gt;では、複数のスレッドを起動してやることは?というと並行処理です。&lt;/p&gt;
&lt;h2 id="並行処理"&gt;並行処理&lt;/h2&gt;
&lt;p&gt;これもすでに出てきている話ではあります。&lt;a href="https://uh-zz.github.io/blog/posts/about-process/" target="_blank" rel="noopener"&gt;プロセス管理&lt;/a&gt;の記事で出した複数アプリを同時に起動させるという部分です。&lt;/p&gt;
&lt;p&gt;「同時に」というのは私たちユーザがそう解釈しているだけで、アプリは&lt;strong&gt;カーネル&lt;/strong&gt;が割り当てた非常に短い処理時間ごとに切り替えているのでしたよね。これが&lt;strong&gt;並行処理&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;スレッドでも同じように短い処理時間ごとに切り替えて「同時に」処理させることができます。&lt;/p&gt;
&lt;h3 id="並列処理との違い"&gt;並列処理との違い&lt;/h3&gt;
&lt;p&gt;私自身、再三調べては納得 → 忘れるを繰り返していましたが、&lt;a href="https://uh-zz.github.io/blog/posts/about-process/" target="_blank" rel="noopener"&gt;プロセス管理&lt;/a&gt;(3 度目)をまとめることでやっと理解できたと思います。&lt;/p&gt;
&lt;p&gt;並行処理では処理時間ごとに切り替えると言いましたが、並列処理では CPU １つは言わず２つで処理してしまえばいいじゃないという考え方です。&lt;/p&gt;
&lt;p&gt;図で見ると非常にわかりやすいのですが、並行処理だとパン食べてチーズ食べてハム食べてレタス食べて、、を繰り返して食べ切る作戦なのに対して、並列処理はミックスサンドとして食べ切るようなイメージです。&lt;/p&gt;
&lt;p&gt;そんなの絶対ミックスサンドとして処理したら無限じゃんと思われますが、並列処理にも上限があるようです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;アムダールの法則といって複数のプロセッサ(CPU のことですね)を使って並列化による高速化を行う場合、そのプログラムの中で逐次的に実行される処理部分(並列)の時間によって、高速化が制限されるというものです。&lt;/p&gt;
&lt;p&gt;出典：&lt;a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%A0%E3%83%80%E3%83%BC%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87" target="_blank" rel="noopener"&gt;wikipedia「アムダールの法則」より引用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;まあ、上限があるといっても高速するのに変わりはないわけです。&lt;/p&gt;
&lt;p&gt;今回はその中でも比較的面白い実装を見つけたのでそれを紹介します。&lt;/p&gt;
&lt;h2 id="ワーカープール"&gt;ワーカープール&lt;/h2&gt;
&lt;p&gt;スレッドプールとも呼ばれるものです。並行処理でたくさんのスレッドを起動して、、というのももちろん可能ですが、それには代償が伴います。&lt;/p&gt;
&lt;p&gt;ワーカープールはそのようにいくつもスレッドを起動させるのではなく、すでに起動したスレッドを使い回そうの精神で実装される並行処理です。&lt;/p&gt;
&lt;p&gt;以下のような実装です。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://oohira.github.io/gobyexample-jp/worker-pools.html" target="_blank" rel="noopener"&gt;こちら&lt;/a&gt;を参考にさせていただきました。&lt;/p&gt;
&lt;p&gt;(ほぼコメントつけただけですが)&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package main
import (
&amp;#34;fmt&amp;#34;
&amp;#34;time&amp;#34;
)
// 使い回し用のワーカー
func worker(id int, jobs &amp;lt;-chan int, results chan&amp;lt;- int) {
for j := range jobs {
fmt.Println(&amp;#34;worker&amp;#34;, id, &amp;#34;started job&amp;#34;, j)
time.Sleep(time.Second) // 1秒待ち(重い処理を想定)
fmt.Println(&amp;#34;worker&amp;#34;, id, &amp;#34;finished job&amp;#34;, j)
results &amp;lt;- j * 2
}
}
func main() {
// タスクの数
const numJobs = 5
// こなさなければいけないタスク
jobs := make(chan int, numJobs)
// タスクの成果物
results := make(chan int, numJobs)
for w := 1; w &amp;lt;= 3; w++ {
// 使い回し用のワーカーだけ生成しておく(この状態ではまだタスクをもらってないのでブロック)
go worker(w, jobs, results)
}
// タスク数だけjobsに渡す
for j := 1; j &amp;lt;= numJobs; j++ {
// チャネルへの書き込みを契機にワーカー起動
jobs &amp;lt;- j
}
// タスク数だけ格納されたらチャネルを閉じる
close(jobs)
for a := 1; a &amp;lt;= numJobs; a++ {
&amp;lt;-results
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex="0"&gt;&lt;code&gt;// 結果
worker 3 started job 1
worker 1 started job 2
worker 2 started job 3
worker 3 finished job 1
worker 3 started job 4
worker 1 finished job 2
worker 1 started job 5
worker 2 finished job 3
worker 1 finished job 5
worker 3 finished job 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;実行するとわかりますが、順番がごっちゃになって処理されているのがわかります。&lt;/p&gt;</description></item><item><title>メモリ管理</title><link>https://uh-zz.github.io/posts/category/computer-science/2020/10/memory-management/</link><pubDate>Mon, 05 Oct 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/computer-science/2020/10/memory-management/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;h2 id="仮想メモリ"&gt;仮想メモリ&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://uh-zz.github.io/blog/posts/about-process/" target="_blank" rel="noopener"&gt;プロセス管理&lt;/a&gt;でもあったように、メモリはアドレス空間ごとにプロセスを管理します。&lt;/p&gt;
&lt;p&gt;アドレス空間は 4KB/8KB 単位の&lt;strong&gt;ページ&lt;/strong&gt;に分割して管理されています。&lt;/p&gt;
&lt;p&gt;ページはそれぞれ論理アドレス、物理アドレスを対応づける単位でもあります。&lt;/p&gt;
&lt;p&gt;論理アドレスと物理アドレスは常に紐づけられているわけではなく、そのページが必要になった時点で割り当てることも可能です。&lt;/p&gt;
&lt;p&gt;そのため、論理アドレスを実際の物理アドレスの容量より大きく確保することができます。&lt;/p&gt;
&lt;p&gt;(実際に使えるメモリの量よりも大きなメモリを想定できるということです。)&lt;/p&gt;
&lt;p&gt;仮装メモリとして使う仕組みには次の３つが挙げられます。&lt;/p&gt;
&lt;h2 id="ページング"&gt;ページング&lt;/h2&gt;
&lt;p&gt;仮想メモリといえばこれ、という風に教えられるものの筆頭かと思います。&lt;/p&gt;
&lt;p&gt;ハードディスクを物理メモリの代わりに使うといったものです。&lt;/p&gt;
&lt;p&gt;物理メモリが不足すると、OS のコアである&lt;strong&gt;カーネル&lt;/strong&gt;は使われていないページをハードディスクに移して論理アドレスを解放します。&lt;/p&gt;
&lt;p&gt;そしてプロセスがハードディスクに移されたページにアクセスしようとすると、カーネルがプロセスを停止し、ハードディスクのページを再度物理メモリに読み込み、論理アドレスを対応づけます。&lt;/p&gt;
&lt;p&gt;また、プロセス全体を単位にする場合は&lt;strong&gt;スワッピング&lt;/strong&gt;と呼ばれます。&lt;/p&gt;
&lt;h2 id="メモリマップトファイル"&gt;メモリマップトファイル&lt;/h2&gt;
&lt;p&gt;ファイルをメモリとしてアクセスすることができるものです。&lt;/p&gt;
&lt;p&gt;アクセスがあった瞬間に、カーネルがファイルをメモリに読み込みます。プロセスがメモリを使い終わると、論理アドレスと物理アドレスを解放して、メモリの内容をファイルに保存します。&lt;/p&gt;
&lt;h2 id="共有メモリ"&gt;共有メモリ&lt;/h2&gt;
&lt;p&gt;１つの物理アドレスを、複数のプロセスの論理アドレスに対応づけるものです。
アドレス空間をまたぐと危険では？！という見方もありますが、複数プロセスで処理できるため、巨大な画像データを編集するときには都合が良いみたいです。&lt;/p&gt;
&lt;p&gt;※Go では共有メモリを使わずに Message Passing を使っています。&lt;/p&gt;
&lt;h2 id="メモリ管理-api"&gt;メモリ管理 API&lt;/h2&gt;
&lt;h3 id="malloc3"&gt;malloc(3)&lt;/h3&gt;
&lt;p&gt;メモリを&lt;strong&gt;ヒープ領域&lt;/strong&gt;に割り当てます。プログラム実行時に決まるサイズのメモリはヒープ領域から確保します。&lt;/p&gt;
&lt;p&gt;ヒープは「何かを積み重ねた山」のことで、その名の通り、プログラムを実行してから決定する量だけメモリを確保しておく領域なので納得です。&lt;/p&gt;
&lt;p&gt;malloc で確保したメモリは&lt;a href="#free"&gt;free&lt;/a&gt;で解放しなければいけません。&lt;/p&gt;
&lt;h3 id="calloc3"&gt;calloc(3)&lt;/h3&gt;
&lt;p&gt;メモリをヒープ領域に割り当てます。malloc と異なる点は、割り当てたメモリをゼロクリアすることです。&lt;/p&gt;
&lt;p&gt;こちらも malloc 同様、確保したメモリは&lt;a href="#free"&gt;free&lt;/a&gt;で解放しなければいけません。&lt;/p&gt;
&lt;h3 id="realloc3"&gt;realloc(3)&lt;/h3&gt;
&lt;p&gt;malloc で割り当てたメモリのサイズを拡大、縮小します。こちらも確保したメモリは&lt;a href="#free"&gt;free&lt;/a&gt;で解放しなければいけません。&lt;/p&gt;
&lt;h3 id="free"&gt;free&lt;/h3&gt;
&lt;p&gt;割り当てたメモリを開放します。いったん開放したアドレスにはアクセスしてはいけません。&lt;/p&gt;
&lt;p&gt;メモリの開放漏れを防ぐために、malloc で確保したメモリは常に free で開放されるべきです。&lt;/p&gt;
&lt;h3 id="brk2"&gt;brk(2)&lt;/h3&gt;
&lt;p&gt;malloc や realloc が割り当てるためのメモリを探してくるものです。&lt;/p&gt;
&lt;p&gt;物理アドレスが割り当てられていないページに物理アドレスを対応づけます。&lt;/p&gt;
&lt;h3 id="余談"&gt;余談&lt;/h3&gt;
&lt;p&gt;メモリはエラーでもかなりお世話になる部分なので、次回以降、実際のエラーやプログラミング言語(Go か Java)に絡めた記事を書きたいです。&lt;/p&gt;
&lt;h2 id="備考"&gt;備考&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E7%AC%AC2%E7%89%88-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797386479" target="_blank" rel="noopener"&gt;ふつうの Linux プログラミング 第 2 版 Linux の仕組みから学べる gcc プログラミングの王道&lt;/a&gt;&lt;/p&gt;</description></item><item><title>プロセス管理</title><link>https://uh-zz.github.io/posts/category/computer-science/2020/09/process-management/</link><pubDate>Sun, 05 Jul 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/computer-science/2020/09/process-management/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;h2 id="プロセスとは"&gt;プロセスとは&lt;/h2&gt;
&lt;p&gt;プロセスという概念は Linux において、ファイルシステム、ストリームに並んで重要な構成要素の１つです。&lt;/p&gt;
&lt;p&gt;プログラマが作成したソースコードはファイルに保存されます。そしてファイルの保存先はハードディスクです。&lt;/p&gt;
&lt;p&gt;プログラムの実行時、プログラムはハードディスクからメモリへと読み込まれます。&lt;/p&gt;
&lt;p&gt;CPU はメモリに読み込まれたプログラムを順次処理していきます。このとき、メモリに読み込まれて CPU に処理されているプログラムを&lt;strong&gt;プロセス&lt;/strong&gt;といいます。&lt;/p&gt;
&lt;p&gt;１つのプロセスを処理できるのは１つの CPU のみです。&lt;/p&gt;
&lt;p&gt;そのため、同じプロセスしか一度に実行できなくなるといったことを避けるために、CPU はプロセスごとに処理時間を決めて次々に切り替えます。&lt;/p&gt;
&lt;p&gt;普段使っている PC やスマホは Youtube や Line や Twitter など、複数アプリを同時に起動して使用しています。&lt;/p&gt;
&lt;p&gt;あれは CPU が処理時間を決めて順に処理しているために実現されています。&lt;/p&gt;
&lt;p&gt;OS のコアである&lt;strong&gt;カーネル&lt;/strong&gt;はプロセスの優先順位を考慮して、各プロセスに処理時間を割り当てます。&lt;/p&gt;
&lt;p&gt;(この機能を&lt;strong&gt;スケジューラ&lt;/strong&gt;、または&lt;strong&gt;ディスパッチャ&lt;/strong&gt;といいます。)&lt;/p&gt;
&lt;h2 id="アドレス空間"&gt;アドレス空間&lt;/h2&gt;
&lt;p&gt;プロセス１つに対して、CPU とメモリがそれぞれ１つ必要です。CPU は前述の通り、処理時間を割り当てるのに対し、メモリはプロセスごとに&lt;strong&gt;アドレス空間&lt;/strong&gt;を割り当てます。&lt;/p&gt;
&lt;p&gt;メモリにプログラムを書き込む際には&lt;strong&gt;アドレス&lt;/strong&gt;が必要です。&lt;/p&gt;
&lt;p&gt;しかしプロセスには 0 番地から始まるメモリが必要なため、１つのプロセスしか使えなくなってしまいます。&lt;/p&gt;
&lt;p&gt;そこでプロセスから見えるアドレス(&lt;strong&gt;論理アドレス&lt;/strong&gt;)と実際のアドレス(&lt;strong&gt;物理アドレス&lt;/strong&gt;)を分けてしまいます。&lt;/p&gt;
&lt;p&gt;こうすることで、カーネルと CPU によって論理アドレス → 物理アドレスと変換された実際のアドレスに対して書き込むことができます。&lt;/p&gt;
&lt;p&gt;１つのプロセスの論理アドレス、物理アドレスを全体として&lt;strong&gt;アドレス空間&lt;/strong&gt;といいます。&lt;/p&gt;
&lt;p&gt;アドレス空間はプロセスごとに割り当てられるので他のプロセスにアクセスできなくなります。&lt;/p&gt;
&lt;h2 id="プロセス-api"&gt;プロセス API&lt;/h2&gt;
&lt;h3 id="fork2"&gt;fork(2)&lt;/h3&gt;
&lt;p&gt;自分のプロセスを複製して新しいプロセスを作ります。&lt;/p&gt;
&lt;p&gt;Github でも fork がありますが、意味合いは同じです。既存のリポジトリを複製します。複製したリポジトリは自由に更新できますが、fork した元のリポジトリに対しては更新はできません。&lt;/p&gt;
&lt;p&gt;プロセスの fork は元からあるプロセスを&lt;strong&gt;親プロセス&lt;/strong&gt;、複製されたプロセスを&lt;strong&gt;子プロセス&lt;/strong&gt;と呼びます。&lt;/p&gt;
&lt;p&gt;子プロセスの fork 実行時の戻り値は 0 です。&lt;/p&gt;
&lt;p&gt;(戻り値 0 は正常終了のステータスコード)そして親プロセスの fork 実行時の戻り値は子プロセスのプロセス ID です。&lt;/p&gt;</description></item></channel></rss>