<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on puffer-fish</title><link>https://uh-zz.github.io/tags/go/</link><description>Recent content in Go on puffer-fish</description><generator>Hugo -- gohugo.io</generator><language>jp</language><lastBuildDate>Tue, 11 Jun 2024 00:00:00 +0900</lastBuildDate><atom:link href="https://uh-zz.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Conference 2024参加レポ</title><link>https://uh-zz.github.io/posts/category/look-back-on/2024/06/08/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/look-back-on/2024/06/08/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;先日、オフラインで開催された Go Conference 2024 に参加してきました。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gocon.jp/2024/" target="_blank" rel="noopener"&gt;https://gocon.jp/2024/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Go Conference で登壇デビューできた感想と、リアタイできた発表のレポートをしていきます。&lt;/p&gt;
&lt;p&gt;発表レポ(というか感想)は、&lt;a href="#%e3%83%aa%e3%82%a2%e3%82%bf%e3%82%a4%e3%81%a7%e3%81%8d%e3%81%9f%e7%99%ba%e8%a1%a8"&gt;リアタイできた発表&lt;/a&gt;をご参照ください。(しばらくポエムになります)&lt;/p&gt;
&lt;h2 id="発表緊張した"&gt;発表緊張した…&lt;/h2&gt;
&lt;p&gt;当日の発表スライドはこちらです&lt;/p&gt;
&lt;iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/3e521da6f3e84afab30dd21521cc361d" title="自動生成されたhttpエンドポイントごとにカスタムミドルウェアを挿入したい話" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 60%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://gocon.jp/2024/sessions/21/" target="_blank" rel="noopener"&gt;https://gocon.jp/2024/sessions/21/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;まずは、発表のためにフィードバックをいただいた皆さんほんとにありがとうございました！！&lt;/p&gt;
&lt;p&gt;また、激励してくれた同僚＆元同僚にもほんとに感謝です &amp;#x1f64f;&lt;/p&gt;
&lt;p&gt;どうしても発表は緊張するものなのですが、スライドはみんなに見てもらって恥ずかしくないものを持ってきた、というのが心の支えになりました。&lt;/p&gt;
&lt;p&gt;おかげで、当日は気持ちよく発表することができました。&lt;/p&gt;
&lt;p&gt;会場からの反応もいただくことができて、発表後のエゴサが止まりませんでした笑&lt;/p&gt;
&lt;p&gt;こちらもありがとうございます&amp;#x1f44b;&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="ja" dir="ltr"&gt;足向けて寝られないぐらいお世話になってる oapi-codegen&lt;a href="https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#gocon&lt;/a&gt;&lt;/p&gt;&amp;mdash; RADISH (@ruby_engineer) &lt;a href="https://twitter.com/ruby_engineer/status/1799386755399033217?ref_src=twsrc%5Etfw"&gt;June 8, 2024&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="ja" dir="ltr"&gt;oapi-codegenの生成コードを使うと、endpointごとに個別のミドルウェアを差し込めない課題がある。&lt;br&gt;わかる！そうだよそこだよ！&lt;br&gt; &lt;a href="https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#gocon&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鹿 (@mizushika1) &lt;a href="https://twitter.com/mizushika1/status/1799386957409403298?ref_src=twsrc%5Etfw"&gt;June 8, 2024&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="ja" dir="ltr"&gt;oapi-codegenメインで使ってるから助かる&lt;a href="https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#gocon&lt;/a&gt;&lt;/p&gt;&amp;mdash; パンダム/rymiyamoto (@rymiyamoto129) &lt;a href="https://twitter.com/rymiyamoto129/status/1799387433102172397?ref_src=twsrc%5Etfw"&gt;June 8, 2024&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="ja" dir="ltr"&gt;ちょうど oapi-codegen で chi のサーバーボイラープレートを試してたけど、パスごとのカスタムミドルウェア周り課題あるなあというのを思ってた &lt;a href="https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#gocon&lt;/a&gt;&lt;/p&gt;</description></item><item><title>球面三角法による２点間の距離計算をGoで実装してみた</title><link>https://uh-zz.github.io/posts/category/go/2020/07/spherical-trigonometry/</link><pubDate>Mon, 06 Jul 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/go/2020/07/spherical-trigonometry/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;p&gt;地球上の２点間の距離計算ってアプリだと Google Map API を使えば完了！だと思いますが、どう計算してるかって気になりますよね？&lt;/p&gt;
&lt;p&gt;今回は球面三角法を利用した地球上の２点間の距離計算を Go で実装します。（調べたらフツーにあるんですが）&lt;/p&gt;
&lt;h2 id="球面三角法とは"&gt;球面三角法とは&lt;/h2&gt;
&lt;p&gt;その名の通り、三角関数を利用して球面上の辺や角の大きさを導出するものです。平面と球面とでの違いは辺の大きさが
球面では中心角によって表されることにあります。&lt;/p&gt;
&lt;p&gt;よって、球面三角法を使用して算出した弧の長さ(中心角)と赤道の半径を乗算すると距離が求まります。&lt;/p&gt;
&lt;p&gt;球面三角法の証明については、&lt;a href="http://horibe.jp/PDFBOX/SphericalTriangles.pdf" target="_blank" rel="noopener"&gt;球面三角形の定理&lt;/a&gt;を参考にしました！&lt;/p&gt;
&lt;p&gt;(&amp;ldquo;高校生に向けて&amp;quot;とある通り、非常にわかりやすかったです)&lt;/p&gt;
&lt;p&gt;球面三角法の余弦定理を利用して実際に距離を算出する方法は&lt;a href="https://qiita.com/port-development/items/eea3a0a225be47db0fd4#%E7%90%83%E9%9D%A2%E4%B8%89%E8%A7%92%E6%B3%95%E3%81%AE%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86" target="_blank" rel="noopener"&gt;球面三角法の余弦定理&lt;/a&gt;がわかりやすいです。&lt;/p&gt;
&lt;h2 id="実装"&gt;実装&lt;/h2&gt;
&lt;p&gt;実装したソースコードは Github でも確認できます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/uh-zz/traning/tree/master/algorithm/distance" target="_blank" rel="noopener"&gt;球面三角法を利用した２点間の距離計算&lt;/a&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package main
import &amp;#34;math&amp;#34;
// Coordinate 緯度経度
type Coordinate struct {
Longitude float64
Latitude float64
}
// EarthRadius 赤道半径
const EarthRadius = 6378140
// DistanceOnTheEarth 地球上の 2 点間の距離を出す（球面三角法）
func DistanceOnTheEarth(from, to Coordinate) float64 {
fromLadLon := from.Longitude * math.Pi / 180
fromLadLat := from.Latitude * math.Pi / 180
toLadLon := to.Longitude * math.Pi / 180
toLadLat := to.Latitude * math.Pi / 180
alpha := math.Sin(fromLadLat)*math.Sin(toLadLat) +
math.Cos(fromLadLat)*math.Cos(toLadLat)*math.Cos(fromLadLon-toLadLon)
arcAlpha := math.Acos(alpha)
return arcAlpha * EarthRadius / 1000
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="動かしてみる"&gt;動かしてみる&lt;/h2&gt;
&lt;p&gt;それでは実装した Go の関数を呼び出す簡単なアプリを動かしていきます。&lt;/p&gt;</description></item><item><title>ソートアルゴリズムをGoで実装してみた</title><link>https://uh-zz.github.io/posts/category/go/2020/07/compare-sort-aligorithm/</link><pubDate>Sun, 05 Jul 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/go/2020/07/compare-sort-aligorithm/</guid><description>&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;バックエンドエンジニアの&lt;a href="https://github.com/kamranahmedse/developer-roadmap#back-end-roadmap" target="_blank" rel="noopener"&gt;ロードマップ&lt;/a&gt;に沿ってエンジニアとしての自己肯定感を養うシリーズです。&lt;/p&gt;
&lt;h2 id="マージソート"&gt;マージソート&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;マージソートは、ソートのアルゴリズムで、既に整列してある複数個の列を 1 個の列にマージする際に、小さいものから先に新しい列に並べれば、新しい列も整列されている、というボトムアップの分割統治法による。大きい列を多数の列に分割し、そのそれぞれをマージする作業は並列化できる。&lt;/p&gt;
&lt;p&gt;出典：&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88#:~:text=%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AF%E3%80%81%E3%82%BD%E3%83%BC%E3%83%88%E3%81%AE,%E4%BD%9C%E6%A5%AD%E3%81%AF%E4%B8%A6%E5%88%97%E5%8C%96%E3%81%A7%E3%81%8D%E3%82%8B%E3%80%82" target="_blank" rel="noopener"&gt;wikipedia「マージソート」より引用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最悪の計算量が O(n log n) であるから少なくとも O(n^2)よりは速いんだろうなという印象（雑すぎるか）&lt;/p&gt;
&lt;p&gt;以下「&lt;a href="https://qiita.com/drken/items/44c60118ab3703f7727f" target="_blank" rel="noopener"&gt;ソートを極める！ 〜 なぜソートを学ぶのか 〜&lt;/a&gt;」を元に実装してみた（なるべくソースを見ないで実装を試みたがマージする箇所は折れた、、）&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package main
import (
&amp;#34;fmt&amp;#34;
&amp;#34;time&amp;#34;
&amp;#34;github.com/uh-zz/traning/algorithm/shuffle&amp;#34;
)
func main() {
// ランダムな要素 n 個のスライス取得
input := shuffle.RandomIntList(n)
inputLength := len(input)
// マージソート
MergeSort(&amp;amp;input, 0, inputLength)
}
// MergeSort マージソート
func MergeSort(input \*[]int, left, right int) {
// 要素数1つの場合は抜ける
if right-left == 1 {
return
}
// 配列を２つに分けるインデックス
middle := left + (right-left)/2
// 配列左側
MergeSort(input, left, middle)
// 配列右側
MergeSort(input, middle, right)
var buffer []int
// 左側と右側をバッファにためる（右側反転）
for index := left; index &amp;lt; middle; index++ {
buffer = append(buffer, (*input)[index])
}
for index := right - 1; index &amp;gt;= middle; index-- {
buffer = append(buffer, (*input)[index])
}
// マージする
scopeLeft := 0
scopeRight := len(buffer) - 1
for index := left; index &amp;lt; right; index++ {
if buffer[scopeLeft] &amp;lt;= buffer[scopeRight] {
// 左側採用
(*input)[index] = buffer[scopeLeft]
scopeLeft++
} else {
// 右側採用
(*input)[index] = buffer[scopeRight]
scopeRight--
}
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これ考えたのぶっ飛んでるなあと思って Wikipedia 見てたら、考案者が&lt;a href="https://ja.wikipedia.org/wiki/%E3%82%B8%E3%83%A7%E3%83%B3%E3%83%BB%E3%83%95%E3%82%A9%E3%83%B3%E3%83%BB%E3%83%8E%E3%82%A4%E3%83%9E%E3%83%B3" target="_blank" rel="noopener"&gt;フォン・ノイマン&lt;/a&gt;でやっぱりぶっ飛んでた（凄すぎ）&lt;/p&gt;</description></item></channel></rss>